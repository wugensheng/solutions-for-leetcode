## 1. 数组（12）

### 二分

#### [704. 二分查找](https://leetcode.cn/problems/binary-search/)√

```` java
class Solution {
  	// 二分查找某一个数是否存在，存在返回其下标
    public int search(int[] nums, int target) {
        if (target < nums[0] || target > nums[nums.length - 1]) return -1;
        int left = 0, right = nums.length - 1;
      	// 左闭右闭区间，表示目标存在的有效范围
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target) return mid;
            else if (nums[mid] > target) right = mid - 1;
            else if (nums[mid] < target) left = mid + 1;
        }
        return -1;
    }
}
````



#### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)√

``` java
class Solution {
    public int searchInsert(int[] nums, int target) {
        if (target < nums[0]) return 0;
        if (target > nums[nums.length - 1]) return nums.length;
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target) return mid;
            else if (nums[mid] > target) right = mid - 1;
            else if (nums[mid] < target) left = mid + 1;
        }
        // right是target存在的右区间，如果循环结束，没有找到target
        // target插入的位置是right + 1
        return right + 1;
    }
}
```



#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)√

``` java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0 || target < nums[0] || target > nums[nums.length - 1]) {
            return new int[]{-1, -1};
        }
        // 右边界
        int left = 0, right = nums.length - 1;
        int rightBorder = -2, leftBorder = -2;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] > target) right = mid - 1;
            else {
                left = mid + 1;
                rightBorder = left;
            }
        }
        // 左边界
        left = 0;
        right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] < target) left = mid + 1;
            else {
                right = mid - 1;
                leftBorder = right;
            }
        }
        if (rightBorder > leftBorder + 1) {
            return new int[]{leftBorder + 1, rightBorder - 1};
        }
        return new int[]{-1, -1};
    }
}
```

-----

### 其他

#### [27. 移除元素](https://leetcode.cn/problems/remove-element/)

``` java
// 双指针思想
class Solution {
    public int removeElement(int[] nums, int val) {
        // fastIndex指向需要放入数组中的数
        // lowIndex指向新数组的下标
        int lowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.length; fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[lowIndex++] = nums[fastIndex];
            }
        }
        return lowIndex;
    }
}
```

#### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

``` java
// 双指针思想
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 1) return 1;
        // newIndex：指向新数组下标
        // index：指向当前数组中的数据
        int newIndex = 0, index = 0;
        nums[newIndex++] = nums[index++];
        for (; index < nums.length; index++) {
            if (nums[index] != nums[newIndex - 1]) {
                nums[newIndex++] = nums[index];
            } 
        }
        return newIndex;
    }
}
```

#### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

``` java
// 双指针思想
class Solution {
  	// 先放非0，再补0
    public void moveZeroes(int[] nums) {
        // newIndex：指向新数组下标
        // index： 指向数组下标, 需要放入新数组中的数
        int newIndex = 0, index = 0;
        for (; index < nums.length; index++) {
            if (nums[index] != 0) {
                nums[newIndex++] = nums[index];
            }
        }
        for (; newIndex < nums.length; newIndex++) {
            nums[newIndex] = 0;
        }
    }
}
```

#### [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

``` java
// 双指针思想
// 双指针模拟栈
class Solution {
    public boolean backspaceCompare(String s, String t) {
        int newIndex1 = 0;
        char[] ss = s.toCharArray(), tt = t.toCharArray();
        for (int i = 0; i < ss.length; i++) {
            if (ss[i] != '#') ss[newIndex1++] = ss[i];  // 入栈
            else {
                newIndex1--; // 出栈
                if (newIndex1 < 0) newIndex1 = 0; 
            }
        }
        int newIndex2 = 0;
        for (int i = 0; i < tt.length; i++) {
            if (tt[i] != '#') tt[newIndex2++] = tt[i]; // 入栈
            else {
                newIndex2--; // 出栈
                if (newIndex2 < 0) newIndex2 = 0;
            }
        }
        if (newIndex1 != newIndex2) return false;
        for (int i = 0; i < newIndex1; i++) {
            if (ss[i] != tt[i]) return false;
        }
        return true;
    }
}
```



#### [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

``` java
// 双指针
class Solution {
    public int[] sortedSquares(int[] nums) {
        // begin: 指向数组开头
        // end: 指向数组结尾
        // lastIndex: 指向新数组的最后一个数
        int[] result = new int[nums.length];
        int begin = 0, end = nums.length - 1, lastIndex = nums.length - 1;
        while (begin <= end) {
            int a = nums[begin] * nums[begin], b = nums[end] * nums[end];
            if (a > b) {
                result[lastIndex--] = a;
                begin++; 
            } else {
                result[lastIndex--] = b;
                end--;
            }
        }
        return result;
    }
}
```



#### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

``` java
// 滑动窗口，非重复遍历所有有可能区间
// 双指针思想
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        // left：窗口的左边界
        // right： 窗口的有边界
        // sum: 窗口的总和
        int left = 0, result = Integer.MAX_VALUE;
        int sum = 0;
        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];
            while (sum >= target) {
                result = Math.min(result, right - left + 1);
                sum -= nums[left++];
            }
        }
        return result == Integer.MAX_VALUE ? 0 : result;
    }
}
```



#### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

``` java
// 滑动窗口
// 双指针
class Solution {
    public String minWindow(String s, String t) {
        int[] mark = new int[256];
        int[] source = new int[256];
        char[] ss = s.toCharArray(), tt = t.toCharArray();
        for (int i = 0; i < tt.length; i++) {
            source[tt[i]] += 1;
        }
        int left = 0; // 滑动窗口左区间
        int length = Integer.MAX_VALUE; // 区间长度
        int begin = -1, end = -1; // 结果的左右区间
        for (int right = 0; right < ss.length; right++) {
            mark[ss[right]] += 1;
            while (isContant(mark, source)) {  // 窗口满足条件，对最小的答案区间进行更新，直至不满去条件
                if (length > right - left + 1) {
                    begin = left;
                    end = right;
                }
                length = end - begin + 1;
                mark[ss[left]] -= 1;
                left++;
            }
        }
        return begin == -1 ? "" : s.substring(begin, end + 1);
    }

    public Boolean isContant(int[] mark, int[] source) {
        for (int i = 0; i < 256; i++) {
            if (mark[i] < source[i]) {
                return false;
            }
        }
        return true;
    }
}
```

### 模拟

#### [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

``` java
class Solution {
    // 核心：循环遍历所有x，y位置
    public int[][] generateMatrix(int n) {
        int[][] result = new int[n][n];
        int x = 0, y = 0; // 坐标
        int count = 1; // 填充数字
        
        // loop 为圈数
        for (int loop = 0; loop < n / 2; loop++) {
            // 上 x不变，y++
            for (y = loop, x = loop; y < n - loop - 1; y++){
                result[x][y] = count++;
            }

            // 右 y不变 x++
            for (; x < n - loop - 1; x++) {
                result[x][y] = count++;
            }

            // 下 x不变 y--
            for (; y > loop; y--) {
                result[x][y] = count++;
            }

            // 左 y不变 x--
            for (; x > loop; x--) {
                result[x][y] = count++;
            }
        }
        if (n % 2 == 1) {
            result[n / 2][n / 2] = count;
        }
        return result;
    }
}
```

#### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

``` java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int h = matrix.length, w = matrix[0].length;
        int maxLoop = Math.min(h, w) / 2;
        List<Integer> result = new ArrayList<>();
        int index = 0;
        int x = 0, y = 0;

        for (int loop = 0; loop < maxLoop; loop++) {
            for (y = loop, x = loop; y < w - loop - 1; y++) {
                result.add(matrix[x][y]);
            }

            for (; x < h - loop - 1; x++) {
                result.add(matrix[x][y]);
            }

            for (; y > loop; y--) {
                result.add(matrix[x][y]);
            }

            for (; x > loop; x--) {
                result.add(matrix[x][y]);
            }
        }

        // 考虑到短边的奇偶会影响到最终剩下格子数量
        if (Math.min(h, w) % 2 == 1) {
            if (h == w) {
                result.add(matrix[h / 2][h /2]);
            } else if (h < w) { // 竖着剩下
                for (y = maxLoop, x = maxLoop; y < w - maxLoop; y++) {
                    result.add(matrix[x][y]);
                }
            } else { // 横着剩下
                for (y = maxLoop, x = maxLoop; x < h - maxLoop; x++) {
                    result.add(matrix[x][y]);
                }
            }
        }
        return result;
    }
}
```



## 2. 链表（7）

#### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)√

``` java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null) return head;
        ListNode dummy = new ListNode(1, head); // 虚拟头指针
        ListNode pre = dummy; 
        ListNode cur = head;

        while (cur != null) {
            if (cur.val == val) {
                pre.next = cur.next;
            } else {
                pre = cur;
            }
            cur = cur.next;
        }
        return dummy.next;
    }
}
```

#### [707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

``` java
class MyLinkedList {
    ListNode head;
    int count;
    ListNode dummy;

    public class ListNode {
        int val;
        ListNode next;
        ListNode(){};
        ListNode(int val) {this.val = val;}
        ListNode(int val, ListNode next) {this.val = val; this.next = next;}
    }

    public MyLinkedList() {
        this.head = null;
        this.count = 0;
        this.dummy = new ListNode(-1, this.head);
    }
    
    public int get(int index) {
        if (index > this.count - 1) return -1;
        ListNode cur = this.head;
        for (int i = 0; i < index; i++) {
            cur = cur.next;
        }
        return cur.val;
    }
    
    public void addAtHead(int val) {
        this.count++;
        ListNode node = new ListNode(val, this.head);
        this.dummy.next = node;
        this.head = this.dummy.next;
    }
    
    public void addAtTail(int val) {
        if (this.count == 0) {
            addAtHead(val);
            return;
        }
        this.count++;
        ListNode cur = this.dummy;
        ListNode node = new ListNode(val, null);
        while (cur.next != null) {
            cur = cur.next;
        }
        cur.next = node;
    }
    
    public void addAtIndex(int index, int val) {
        if (index <= 0) {
            addAtHead(val);
            return;
        }
        if (index > this.count) {
            return;
        }
        if (index == this.count) {
            addAtTail(val);
            return;
        }
        ListNode pre = this.dummy, cur = this.head;
        for (int i = 0; i < index; i++) {
            pre = cur;
            cur = cur.next;
        }
        ListNode node = new ListNode(val, cur);
        pre.next = node;
        this.count++;
    }
    
    public void deleteAtIndex(int index) {
        if (index > this.count - 1 || index < 0) return;
        ListNode pre = this.dummy, cur = this.head;
        for (int i = 0; i < index; i++) {
            pre = cur;
            cur = cur.next;
        }
        pre.next = cur.next;
        this.head = this.dummy.next;
        this.count--;
    }
}
```



#### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)√

``` java
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null) return head;
        ListNode cur = head, pre = null, temp = null; // 三个指针
        // cur 指向当前需要翻转的节点
        while (cur.next != null) { // 当前节点的next不为空时，继续翻转，否则当前节点就是最后一个节点
            temp = cur.next; // 先记录当前节点的next节点
            cur.next = pre; // 然后把当前节点指向已经翻转好的pre节点
            pre = cur; // cur翻转完整，pre指向cur
            cur = temp; // cur 指向next节点，即temp
        }
        cur.next = pre;
        return cur;
    }
}
```

#### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)√

``` java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) return head;

        ListNode dummy = new ListNode(-1, head); // 虚拟头节点
        ListNode cur = dummy, temp = null;


        while (cur.next != null && cur.next.next != null) {
            temp = cur.next;
            cur.next = temp.next;
            temp.next = cur.next.next;
            cur.next.next = temp;
            cur = temp;
        }
        return dummy.next; 
    }
}
```



#### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

``` java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1, head);
        ListNode fast = dummy, slow = dummy; // 有可能删除第一个节点
        int count = 0;

        while (fast != null) {
            fast = fast.next;
            count++;
            if (count > (n + 1)) {
                slow = slow.next;
            }
        }

        slow.next = slow.next.next;
        return dummy.next;
    }
}
```



#### [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

``` java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA, curB = headB;
        int countA = 0, countB = 0;
        if (headB == null || headB == null) return null;

        while (curA != null) {
            countA++;
            curA = curA.next;
        }

        while (curB != null) {
            countB++;
            curB = curB.next;
        }
        
        curA = headA;
        curB = headB;
        if (countA > countB) {
            int count = countA - countB;
            while (count > 0) {
                count--;
                curA = curA.next;
            }
        }
        if (countA < countB) {
            int count = countB - countA;
            while (count > 0) {
                count--;
                curB = curB.next;
            }
        }

        while (curA != null || curB != null) {
            if (curA == curB) return curA;
            curA = curA.next;
            curB = curB.next;
        }
        return null;
    }
}
```



#### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

``` java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null) return null;
        ListNode fast = head, slow = head; // 快慢指针

        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (slow == fast) {
                slow = head;
                while (slow != fast) { // 两个指针再次相遇即为入环起点
                    slow = slow.next;
                    fast = fast.next;
                }
                return slow;
            }
        }
        return null;
    }
}
```



## 3. 哈希表（10）

#### [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)√

``` java
// 数组哈希
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] record = new int[26];

        for (int i = 0; i < s.length(); i++) {
            record[s.charAt(i) - 'a']++;
        }
        for (int i = 0; i < t.length(); i++) {
            record[t.charAt(i) - 'a']--;
        }

        for (int i = 0; i < 26; i++) {
            if (record[i] != 0) return false;
        }
        return true;
    }
}
```



#### [383. 赎金信](https://leetcode.cn/problems/ransom-note/)√

``` java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        char[] r = ransomNote.toCharArray(), m = magazine.toCharArray();
        int[] map = new int[26];

        for (int i = 0; i < m.length; i++) map[m[i] - 'a']++;
        for (int i = 0; i < r.length; i++) map[r[i] - 'a']--;

        for (int i = 0; i < 26; i++) {
            if (map[i] < 0) return false;
        }

        return true;
    }
}
```



#### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

``` java
// map
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> resMap = new HashMap<>();
        for (String str : strs) {
            char[] ss = str.toCharArray();
            Arrays.sort(ss);
            List<String> list = resMap.get(Arrays.toString(ss)); // 对字母异味单词排序，看是否有这个集合分类
            if (list != null) {
                list.add(str);
            } else {
                list = new ArrayList<>();
                list.add(str);
                resMap.put(Arrays.toString(ss), list); // 没有这个集合，创建该集合
            }
        }
        List<List<String>> res = new ArrayList<>(); 
        for (String str : resMap.keySet()) {
            res.add(resMap.get(str)); // 取结果
        }
        return res;
    }
}
```



#### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

``` java
// 数组哈希
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int[] pFre = new int[26];
        int[] markFre = new int[26];
        List<Integer> res = new ArrayList<>();
        char[] ss = s.toCharArray(), pp = p.toCharArray(); // 转成数组，速度更快

        int plength = p.length(); // 函数操作速度慢
        for (int i = 0; i < plength; i++) {
            pFre[pp[i] - 'a'] += 1;
        }
        
        int slength = s.length();
        for (int i = 0; i < slength; i++) {
            markFre[ss[i] - 'a'] += 1;
            if (i > plength - 2) {
                if (isTrue(pFre, markFre)) {
                    res.add(i - plength + 1);
                }
                markFre[ss[i - plength + 1] - 'a'] -= 1;
            }
        }

        return res;
    }

    public boolean isTrue(int[] p, int[] q) {
        for (int i = 0; i < 26; i++) {
            if (p[i] != q[i]) return false;
        }
        return true;
    }
}
```



#### [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

``` java
// 数组哈希
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        int[] record = new int[1000]; 
        for (int i = 0; i < nums1.length; i++) {
            record[nums1[i]] = 1;
        }

        int count = 0;
        for (int i = 0; i < nums2.length; i++) {
            if (record[nums2[i]] == 1) {
                record[nums2[i]] = -1;
                count++;
            }
        }
        int[] res = new int[count];
        count = 0;
        for (int i = 0; i < 1000; i++) {
            if (record[i] == -1) res[count++] = i;
        }

        return res;
    }
}
```



#### [350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)

``` java
// 数组哈希
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        int[] num1_record = new int[1001];
        int[] num2_record = new int[1001];

        for (int i = 0; i < nums1.length; i++) {
            num1_record[nums1[i]]++;
        }
        for (int i = 0; i < nums2.length; i++) {
            num2_record[nums2[i]]++;
        }

        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < 1001; i++) {
            if (num1_record[i] > 0 && num2_record[i] > 0) {
                int times = Math.min(num1_record[i], num2_record[i]);
                while (times-- > 0) list.add(i);
            }
        }
        int[] res = new int[list.size()];
        int index = 0;
        for (Integer temp : list) res[index++] = temp;
        return res;
    }
}
```



#### [202. 快乐数](https://leetcode.cn/problems/happy-number/)

``` java
// Set
class Solution {
    public boolean isHappy(int n) {
        Set<Integer> set = new HashSet<>();
        while (!set.contains(n)) {
            set.add(n);
            n = getSum(n);
            if (n == 1) return true;
        }
        return false;
    }

    public int getSum(int n) {
        int sum = 0;
        while (n > 0) {
            int temp = n % 10;
            sum += temp * temp;
            n /= 10;
        }
        return sum;
    }
}
```



#### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

``` java
// Map
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();  // 用map对数组中的数做，值-下标映射
        int[] res = new int[2];
        for (int i = 0; i < nums.length; i++) { // 遍历数组，找map中是否存在差值的key
            if (map.containsKey(target - nums[i])) { // 存在返回结果
                res[0] = i;
                res[1] = map.get(target - nums[i]);
                break;
            }
            map.put(nums[i], i); // 不存在，把这个值-下标存到map中
        }

        return res;
    }
}
```



#### [15. 三数之和](https://leetcode.cn/problems/3sum/)

``` java
class Solution {
  	// 时间复杂度O(n^2)
  	// 双指针思想
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums); // 只关心元素不重复，不关心下标，可以排序

        // 枚举所有a，b，c
        for (int i = 0; i < nums.length; i++) { // 第一层循环枚举a
            if (nums[i] > 0) break; // 剪枝，如果a > 0，则和一定大于0，不可能有组合=0，结束最外层循环

            if (i > 0 && nums[i] == nums[i - 1]) continue; // 对a去重，如果a不是第一个数，并且a和前一个数相同，则三元组会重复

            int left = i + 1, right = nums.length - 1; // 确定a后，在剩下的右侧区间枚举b和c
            while (left < right) { // 如果右侧区间, left指向的b小于right指向的c，则可能存在满足要求的组合
                int sum = nums[i] + nums[left] + nums[right]; // 当前组合的和sum
                if (sum > 0) { // 如果sum大于0，c减小
                    right--;
                } else if (sum < 0) { // 如果sum小于0，b增大
                    left++;
                } else { // 如果等于0则找到a，b，c三元组
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    // 对b和c单独去重
                    while (left < right && nums[left] == nums[left + 1]) left++; // b可能存在多个相同的，找到最右边的b
                    while (left < right && nums[right] == nums[right - 1]) right--; // c可能存在多个相同的，找到最左边的c

                    left++; // 继续
                    right--;
                }
            }
        }

        return result;
    }
}
```



#### [18. 四数之和](https://leetcode.cn/problems/4sum/)

``` java
class Solution {
    // 时间复杂度O(n^3)
  	// 双指针思想
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums); // 与下标无关, a,b,c,d互不相同，且元祖不能完全一样重复

        // 最外层循环枚举a
        for (int i = 0; i < nums.length; i++){
            // 剪枝, 当a > target的时候，如果target非负，或者a非负（以上两种情况都会导致abcd都为非负，则和一定不等于target)
            if (nums[i] > target && (target >= 0 || nums[i] >= 0)) break; 

            if (i > 0 && nums[i] == nums[i - 1]) continue; // 对a去重

            // 第二层循环枚举b， 和a类似
            for (int j = i + 1; j < nums.length; j++) {
                // 剪枝
                if (nums[j] > target - nums[i] && (target - nums[i] >= 0 || nums[j] >= 0)) break;

                //  对b去重
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;

                // 在b的右侧枚举c和d
                int left = j + 1, right = nums.length - 1;
                while (left < right) {
                    int sum = nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum > target) {
                        right--;
                    } else if (sum < target){
                        left++;
                    } else {
                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));
                        while (left < right && nums[left] == nums[left + 1]) left++; // 去重c
                        while (left < right && nums[right] == nums[right - 1]) right--; // 去重d

                        left++;
                        right--;
                    }
                }
            }
        }

        return res;
    }
}
```





## 4. 字符串（7）

#### [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)√

``` java
class Solution {
  	// 双指针
    public void reverseString(char[] s) {
        int left = 0, right = s.length - 1;
        char temp;
        while (left <= right) {
            temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--;
        }
    }
}
```

#### [541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)√

``` java
class Solution {
    public String reverseStr(String s, int k) {
        char[] ss = s.toCharArray();
        int i;
        for (i = 0; i + 2 * k - 1 < ss.length; i += 2 * k) {
            int left = i, right = i + k - 1;
            while (left <= right) {
                char temp = ss[right];
                ss[right] = ss[left];
                ss[left] = temp;
                right--;
                left++;
            }
        }

        int left = i, right = ss.length - i >= k ? i + k - 1: ss.length - 1;
        while (left <= right) {
            char temp = ss[right];
            ss[right] = ss[left];
            ss[left] = temp;
            left++;
            right--;
        }

        return new String(ss);
    }
}
```

#### [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

```java
class Solution {
    public String replaceSpace(String s) {
        if (s == null) return null;

        StringBuilder sb = new StringBuilder(); 
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == ' ') sb.append("%20");
            else {
                sb.append(s.charAt(i));
            }
        }
        return sb.toString(); // 转换
    }
}
```



#### [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

``` java
class Solution {
    public String reverseWords(String s) {
        // 去除字符串中多余空格
        char[] sb = replaceSpace(s).toString().toCharArray();
        // 翻转字符串
        reverseString(sb, 0, sb.length - 1);
        // 翻转单词
        reverseEachWord(sb);

        return new String(sb);
    }

    public void reverseEachWord(char[] sb) {
        int slow = 0, fast = 0;
        while (fast < sb.length) {
            if (fast == sb.length - 1) {
                reverseString(sb, slow, fast);
                fast++;
                continue;
            }
            if (sb[fast] == ' ') {
                reverseString(sb, slow, fast - 1);
                fast++;
                slow = fast;
                continue;
            }
            fast++;
        }
    }

    public void reverseString(char[] s, int start, int end) {
        char temp;
        while (start <= end) {
            temp = s[start];
            s[start] = s[end];
            s[end] = temp;
            start++;
            end--;
        }
    }

    public StringBuilder replaceSpace(String s) {
        StringBuilder sb = new StringBuilder();

        int start = 0, end = s.length() - 1;
        while (s.charAt(start) == ' ') start++;
        while (s.charAt(end) == ' ') end--;

        while (start <= end) {
            if (s.charAt(start) != ' ') sb.append(s.charAt(start));
            else if (s.charAt(start) != s.charAt(start - 1)) {
                sb.append(s.charAt(start));
            }
            start++;
        }
        return sb;
    }
}
```

#### [剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

```` java
class Solution {
  	// 整体翻转 + 局部翻转
    public String reverseLeftWords(String s, int n) {
        char[] ss = s.toCharArray();
        reverseString(ss, 0, n - 1);
        reverseString(ss, n, ss.length - 1);
        reverseString(ss, 0, ss.length - 1);
        return new String(ss);
    }

    public void reverseString(char[] s, int start, int end) {
        char temp;
        while (start <= end) {
            temp = s[start];
            s[start] = s[end];
            s[end] = temp;
            start++;
            end--;
        }
    }
}
````



#### KMP算法 [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

``` java
class Solution {
    public int[] getNext(char[] s) {
        int[] next = new int[s.length]; // next[i]本质是以i下标结尾的字符串的最长相等前后缀的【长度】
        int j = 0; // j指向前缀尾
        for (int i = 1; i < s.length; i++) { // i指向后缀尾
            while (j > 0 && s[i] != s[j]) j = next[j - 1]; // 遇见前后缀不一样，j向前回退
            if (s[i] == s[j]) j++;
            next[i] = j;
        }
        return next;
    }

    public int strStr(String haystack, String needle) {
        char[] s1 = haystack.toCharArray(), s2 = needle.toCharArray();
        int[] next = getNext(s2);
        int j = 0; // j指向模式串
        for (int i = 0; i < s1.length; i++) { // i指向匹配串下标
            while (j > 0 && s2[j] != s1[i]) j = next[j - 1];
            if (s2[j] == s1[i]) j++;
            if (j == s2.length) {
                return i - s2.length + 1;
            }
        }
        return -1;
    }
}
```



#### [459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

``` java
class Solution {
    public int[] getNext(char[] s) {
        int[] next = new int[s.length];
        int j = 0;
        for (int i = 1; i < s.length; i++) {
            while (j > 0 && s[i] != s[j]) j = next[j - 1];
            if (s[i] == s[j]) j++;
            next[i] = j;
        }
        return next;
    }

    public boolean repeatedSubstringPattern(String s) {
        char[] ss = s.toCharArray(); 
        int[] next = getNext(ss); // 获取s的next数组，即最长相等前后缀的长度
        if (next[ss.length - 1] != 0 && ss.length % (ss.length - next[ss.length - 1]) == 0) return true; // 通过最后一个字符的长度和整体长度即可判断是否满足要求
        return false;
    }
}
```



## 5. 双指针（10）

#### [27. 移除元素](https://leetcode.cn/problems/remove-element/)√

``` java
class Solution {
    public int removeElement(int[] nums, int val) {
        // fastIndex指向需要放入数组中的数
        // lowIndex指向新数组的下标
        int lowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.length; fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[lowIndex++] = nums[fastIndex];
            }
        }
        return lowIndex;
    }
}
```

#### [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)√

``` java
class Solution {
    public void reverseString(char[] s) {
        int left = 0, right = s.length - 1;
        char temp;
        while (left <= right) {
            temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--;
        }
    }
}
```

#### [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)√

``` java
class Solution {
    public String replaceSpace(String s) {
        if (s == null) return null;

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == ' ') sb.append("%20");
            else {
                sb.append(s.charAt(i));
            }
        }
        return sb.toString();
    }
}
```



#### [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)√

``` java
class Solution {
    public String reverseWords(String s) {
        // 去除字符串中多余空格
        char[] sb = replaceSpace(s).toString().toCharArray();
        // 翻转字符串
        reverseString(sb, 0, sb.length - 1);
        // 翻转单词
        reverseEachWord(sb);

        return new String(sb);
    }

    public void reverseEachWord(char[] sb) {
        int slow = 0, fast = 0;
        while (fast < sb.length) {
            if (fast == sb.length - 1) {
                reverseString(sb, slow, fast);
                fast++;
                continue;
            }
            if (sb[fast] == ' ') {
                reverseString(sb, slow, fast - 1);
                fast++;
                slow = fast;
                continue;
            }
            fast++;
        }
    }

    public void reverseString(char[] s, int start, int end) {
        char temp;
        while (start <= end) {
            temp = s[start];
            s[start] = s[end];
            s[end] = temp;
            start++;
            end--;
        }
    }

    public StringBuilder replaceSpace(String s) {
        StringBuilder sb = new StringBuilder();

        int start = 0, end = s.length() - 1;
        while (s.charAt(start) == ' ') start++;
        while (s.charAt(end) == ' ') end--;

        while (start <= end) {
            if (s.charAt(start) != ' ') sb.append(s.charAt(start));
            else if (s.charAt(start) != s.charAt(start - 1)) {
                sb.append(s.charAt(start));
            }
            start++;
        }
        return sb;
    }
}
```

``` java
class Solution {
    public String reverseWords(String s) {
        char[] ss = removeSpace(s).toCharArray();
        reverse(ss, 0, ss.length - 1);
        reverseWord(ss);
        return new String(ss);
    }

    public String removeSpace(String s) {
        char[] ss = s.toCharArray();
        int left = 0, right = ss.length - 1;
        while (ss[left] == ' ') left++;
        while (ss[right] == ' ') right--;

        StringBuilder sb = new StringBuilder();
        while (left <= right) {
            if (ss[left] != ' ') sb.append(ss[left]);
            else if (ss[left - 1] != ' ') sb.append(' ');
            left++;
        }
        return sb.toString();
    }

    public void reverse(char[] s, int start, int end) {
        while (start <= end) {
            char temp = s[start];
            s[start] = s[end];
            s[end] = temp;
            start++;
            end--;
        }
    }

    public void reverseWord(char[] s) {
        int left = 0;
        for (int right = 0; right < s.length; right++) {
            if (right == s.length - 1) reverse(s, left, right);
            if (s[right] != ' ') continue;
            reverse(s, left, right - 1);
            left = right + 1;
        }
    }
}
```



#### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

``` java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null) return head;
        ListNode cur = head, pre = null, temp = null;
        // cur 指向当前需要翻转的节点
        while (cur.next != null) {
            temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        cur.next = pre;
        return cur;
    }
}
```

#### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

``` java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1, head);
        ListNode fast = dummy, slow = dummy;
        int count = 0;

        while (fast != null) {
            fast = fast.next;
            count++;
            if (count > (n + 1)) {
                slow = slow.next;
            }
        }

        slow.next = slow.next.next;
        return dummy.next;
    }
}
```



#### [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

``` java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA, curB = headB;
        int countA = 0, countB = 0;
        if (headB == null || headB == null) return null;

        while (curA != null) {
            countA++;
            curA = curA.next;
        }

        while (curB != null) {
            countB++;
            curB = curB.next;
        }
        
        curA = headA;
        curB = headB;
        if (countA > countB) {
            int count = countA - countB;
            while (count > 0) {
                count--;
                curA = curA.next;
            }
        }
        if (countA < countB) {
            int count = countB - countA;
            while (count > 0) {
                count--;
                curB = curB.next;
            }
        }

        while (curA != null || curB != null) {
            if (curA == curB) return curA;
            curA = curA.next;
            curB = curB.next;
        }
        return null;
    }
}
```

#### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

``` java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null) return null;
        ListNode fast = head, slow = head;

        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (slow == fast) {
                slow = head;
                while (slow != fast) {
                    slow = slow.next;
                    fast = fast.next;
                }
                return slow;
            }
        }
        return null;
    }
}
```



#### [15. 三数之和](https://leetcode.cn/problems/3sum/)

``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);

        // 枚举所有a，b，c
        for (int i = 0; i < nums.length; i++) {
            // 如果a > 0 则和一定大于0
            if (nums[i] > 0) break;

            // 对a去重
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            int left = i + 1, right = nums.length - 1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum > 0) {
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    // 对b和c单独去重
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;

                    left++;
                    right--;
                }
            }
        }

        return result;
    }
}
```



#### [18. 四数之和](https://leetcode.cn/problems/4sum/)

``` java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);

        for (int i = 0; i < nums.length; i++){
            if (nums[i] > target && (target >= 0 || nums[i] >= 0)) return res;

            if (i > 0 && nums[i] == nums[i - 1]) continue;

            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] > target - nums[i] && (target - nums[i] >= 0 || nums[j] >= 0)) break;

                if (j > i + 1 && nums[j] == nums[j - 1]) continue;

                int left = j + 1, right = nums.length - 1;
                while (left < right) {
                    int sum = nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum > target) {
                        right--;
                    } else if (sum < target){
                        left++;
                    } else {
                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));
                        while (left < right && nums[left] == nums[left + 1]) left++;
                        while (left < right && nums[right] == nums[right - 1]) right--;

                        left++;
                        right--;
                    }
                }
            }
        }

        return res;
    }
}
```



## 6. 栈与队列（7）

#### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)√

``` java
class MyQueue {

    Stack<Integer> stackIn;
    Stack<Integer> stackOut;

    public MyQueue() {
        stackIn = new Stack<>();
        stackOut = new Stack<>();
    }
    
    public void push(int x) {
        stackIn.push(x);
    }
    
    public int pop() {
        dumpStackIn();
        return stackOut.pop();
    }
    
    public int peek() {
        dumpStackIn();
        return stackOut.peek();
    }
    
    public boolean empty() {
        return stackIn.isEmpty() && stackOut.isEmpty();
    }
  	
  	// 复用
    public void dumpStackIn() {
        if (!stackOut.isEmpty()) return;
        while (!stackIn.isEmpty()) {
            stackOut.push(stackIn.pop());
        }
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```



#### [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)√

```java
class MyStack {

    Queue<Integer> queue1;
    Queue<Integer> queue2; // 辅助队列

    public MyStack() {
        queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }
    
    public void push(int x) {
        // 入栈操作 先把元素放入辅助队列
        queue2.offer(x);
        // 把元素全部放入辅助队列
        while (!queue1.isEmpty()) {
            queue2.offer(queue1.poll());
        }
        Queue<Integer> q = new LinkedList<>();
        q = queue1;
        queue1 = queue2;
        queue2 = q;
    }
    
    public int pop() {
        return queue1.poll();
    }
    
    public int top() {
        return queue1.peek();
    }
    
    public boolean empty() {
        return queue1.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */
```



#### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)√

``` java
class Solution {
    public boolean isValid(String ss) {
        Stack<Character> stack = new Stack<>();
        char[] s = ss.toCharArray();
        for (int i = 0; i < s.length; i++) {
            if (s[i] == '(' || s[i] == '{' || s[i] == '[') stack.push(s[i]);
            else {
                if (stack.isEmpty()) return false;
                char c = stack.pop();
                if ((s[i] == ')' && c != '(') || (s[i] == ']' && c != '[') || (s[i] == '}' && c != '{')) return false;
            }
        }
        if (stack.isEmpty()) return true;
        return false;
    }
}
```



#### [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

``` java
class Solution {
    public String removeDuplicates(String s) {
        char[] ch = s.toCharArray();
        int top = 0; // 栈顶指针 双指针
        for (int i = 0; i < ch.length; i++) {
            if (top == 0 || ch[top - 1] != ch[i]) {
                ch[top++] = ch[i];
                continue;
            }
            top--;
        }
        return new String(ch, 0, top);
    }
}
```



#### [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

``` java
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> stack = new LinkedList(); // deque更快
        // Stack<Integer> stack = new Stack<>();
        // for (int i = 0; i < tokens.length; i++) {
        //     if (tokens[i].equals("+")) {
        //         stack.push(stack.pop() + stack.pop());
        //     } else if (tokens[i].equals("-")) {
        //         stack.push(- stack.pop() + stack.pop());
        //     } else if (tokens[i].equals("*")) {
        //         stack.push(stack.pop() * stack.pop());
        //     } else if (tokens[i].equals("/")) {
        //         int a = stack.pop();
        //         int b = stack.pop();
        //         stack.push(b / a);
        //     } else stack.push(Integer.parseInt(tokens[i]));
        // }
        for (String s : tokens) {
            if (s.equals("+")) {
                stack.push(stack.pop() + stack.pop());
            } else if (s.equals("-")) {
                stack.push(- stack.pop() + stack.pop());
            } else if (s.equals("*")) {
                stack.push(stack.pop() * stack.pop());
            } else if (s.equals("/")) {
                int a = stack.pop();
                int b = stack.pop();
                stack.push(b / a);
            } else stack.push(Integer.parseInt(s));
        }
        return stack.pop();
    }
}
```



#### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

``` java
// 自定义单调递减队列
class MyQueue {
    // LinkedList 删除添加效率高一些
    Deque<Integer> deque = new LinkedList<>();

    // 入队列，若当前值比队列尾值大，则队尾出队列
    public void offer(int val) {
        while (!deque.isEmpty() && deque.peekLast() < val) deque.pollLast();
        deque.offerLast(val);
    } 

    // 弹出队列第一个值
    public void poll(int val) {
        if (!deque.isEmpty() && deque.peekFirst() == val) {
            deque.pollFirst();
        }
    }

    //队列最大值
    public int peek() {
        return deque.peekFirst();
    }
}

class Solution {

    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums.length == 1 || k == 1) return nums;

        int[] res = new int[nums.length - k + 1];
        int index = 0;
        MyQueue myqueue = new MyQueue();

        for (int i = 0; i < k; i++) {
            myqueue.offer(nums[i]);
        }

      	// 模拟移动过程
        res[index++] = myqueue.peek();
        for (int i = k; i < nums.length; i++) {
            myqueue.poll(nums[i - k]);
            myqueue.offer(nums[i]);
            res[index++] = myqueue.peek(); // 窗口最大值
        }

        return res;
    }
}
```



#### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

```` java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // map统计频率
        Map<Integer,Integer> map = new HashMap<>();
        for (Integer num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }

        // 小顶堆
        PriorityQueue<int[]> que = new PriorityQueue<>((pair1, pair2) -> pair1[1] - pair2[1]);
        for (Map.Entry<Integer,Integer> entry : map.entrySet()) {
            // 堆未满直接放入
            if (que.size() < k) {
                que.offer(new int[]{entry.getKey(), entry.getValue()});
            } else {
                // 堆已满，判断是否大于对顶，是则需要放入堆内进行排序
                if (entry.getValue() > que.peek()[1]) {
                    que.poll();
                    que.offer(new int[]{entry.getKey(), entry.getValue()});
                }
            }
        }

        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = que.poll()[0];
        }
        return res;
    }
}
````

## 7. 二叉树（33）

### 二叉树遍历方式

#### 		[144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)√

``` java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        preorder(root, res);
        return res;
    }

    public void preorder(TreeNode node, List<Integer> res) {
        if (node == null) return;
        res.add(node.val);
        preorder(node.left, res);
        preorder(node.right, res);
    }
}
```

#### 		[145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)√

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        postorder(root, res);
        return res;
    }

    public void postorder(TreeNode node, List<Integer> res) {
        if (node == null) return;
        postorder(node.left, res);
        postorder(node.right, res);
        res.add(node.val);
    }
}
```

#### 		[94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)√

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        inorder(root, res);
        return res;
    }

    public void inorder(TreeNode node, List<Integer> res) {
        if (node == null) return;
        inorder(node.left, res);
        res.add(node.val);
        inorder(node.right, res);
    }
}
```

#### 	[102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)√

``` java
 // BFS 借助队列实现广度优先遍历
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if (root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int size = queue.size();
            TreeNode node = null;
            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                node = queue.poll();
                list.add(node.val);
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
            res.add(list);
        }

        return res;
    }
}
```



#### 	[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)√

``` java
// 递归
class Solution {
    public TreeNode invertTree(TreeNode root) {
        preorder(root);
        return root;
    }

    public void preorder(TreeNode root) {
        if (root == null) return;

        // 翻转操作
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;

        // 递归
        preorder(root.left);
        preorder(root.right);
    }
}

// 迭代
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return root;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            // 翻转
            TreeNode temp = node.left;
            node.left = node.right;
            node.right = temp;

            // 入队列
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }

        return root;
    }
}
```



#### 	[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

``` java
 // 递归
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        return compare(root.left, root.right);
    }

    // 比较两颗树是否对称
    public boolean compare(TreeNode tree1, TreeNode tree2) {
        // 终止条件
        if (tree1 == null && tree2 == null) return true;
        if (tree1 == null && tree2 != null) return false;
        if (tree1 != null && tree2 == null) return false;
        if (tree1.val != tree2.val) return false;

        // 递归
        boolean outer = compare(tree1.left, tree2.right);
        boolean inner = compare(tree1.right, tree2.left);
        return outer && inner;
    }
}

// 迭代
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root.left); queue.offer(root.right);

        // 每次都拿一对节点进行比较
        while (!queue.isEmpty()) {
            TreeNode tree1 = queue.poll();
            TreeNode tree2 = queue.poll();
            
            // 终止条件
            if (tree1 == null && tree2 == null) continue;
            if (tree1 == null && tree2 != null) return false;
            if (tree1 != null && tree2 == null) return false;
            if (tree1.val != tree2.val) return false;

            // 成对入队列
            queue.offer(tree1.left); queue.offer(tree2.right);
            queue.offer(tree1.right); queue.offer(tree2.left);
        }

        return true;
    }
}
```

#### 	[100. 相同的树](https://leetcode.cn/problems/same-tree/)

``` java
 // 递归
class Solution {
    public boolean isSameTree(TreeNode tree1, TreeNode tree2) {
        // 终止条件
        if (tree1 == null && tree2 == null) return true;
        if (tree1 == null && tree2 != null) return false;
        if (tree1 != null && tree2 == null) return false;
        if (tree1.val != tree2.val) return false;

        // 递归
        boolean left = isSameTree(tree1.left, tree2.left);
        boolean right = isSameTree(tree1.right, tree2.right);

        return left && right;
    }
}
```



#### 	[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

``` java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return 1 + Math.max(getDepth(root.left), getDepth(root.right));
    }

    // 后序遍历求高度， 根节点的高度==深度
    public int getDepth(TreeNode root) {
        // 终止条件
        if (root == null) return 0;
        // 递归
        int left = getDepth(root.left);
        int right = getDepth(root.right);

        return Math.max(left, right) + 1;
    }
}
```

#### 	[559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)

``` java
class Solution {
    public int maxDepth(Node root) {
        if (root == null) return 0;
        
        int depth = 0;
        for (Node node : root.children) {
            depth = Math.max(depth, getDepth(node));
        }
        return depth + 1;
    }

    // 后序遍历
    public int getDepth(Node root) {
        if (root == null) return 0;

        // 递归
        int depth = 0;
        for (Node node : root.children) {
            depth = Math.max(depth, getDepth(node));
        }

        return depth + 1;
    }
}
```



#### 	[111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

``` java
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;

        if (root.left == null && root.right == null) return 1;
        if (root.left == null) return getDepth(root.right) + 1;
        if (root.right == null) return getDepth(root.left) + 1;
        return Math.min(getDepth(root.left), getDepth(root.right)) + 1;
    }

    // 后序遍历求高度
    public int getDepth(TreeNode root) {
        if (root == null) return 0;

        // 递归
        if (root.left == null && root.right == null) return 1;
        if (root.left == null) return getDepth(root.right) + 1;
        if (root.right == null) return getDepth(root.left) + 1;

        return Math.min(getDepth(root.left), getDepth(root.right)) + 1;
    }
}
```



#### 	[222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

``` java
// 普通二叉树
class Solution {
    public int countNodes(TreeNode root) {
        if (root == null) return 0;

        return getNodes(root.left) + getNodes(root.right) + 1;
    }

    // 后序遍历求节点数
    public int getNodes(TreeNode root) {
        // 终止条件
        if (root == null) return 0;

        // 递归
        int leftCount = getNodes(root.left);
        int rightCount = getNodes(root.right);

        return leftCount + rightCount + 1;
    }
}

// 利用完全二叉树性质
class Solution {
    public int countNodes(TreeNode root) {
        if (root == null) return 0;

        return getNodes(root.left) + getNodes(root.right) + 1;
    }

    public int getNodes(TreeNode root) {
        // 终止条件
        if (root == null) return 0;
        TreeNode cur = root.left;
        int left = 1, right = 1;
        while (cur != null) {
            left++;
            cur = cur.left;
        }
        cur = root.right;
        while (cur != null) {
            right++;
            cur = cur.right;
        }
      	// 判断是否为完全二叉树
        if (left == right) return (1 << left) - 1;


        // 递归
        return getNodes(root.left) + getNodes(root.right) + 1;
    }
}
```



#### 	[110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

``` java
// 平衡二叉树：子树高度差小于等于1
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;

        return getDepth(root) == -1 ? false : true;
    }
  
		// 后序遍历求高度
    public int getDepth(TreeNode root) {
        // 终止条件
        if (root == null) return 0;

        // 递归
        int left = getDepth(root.left);
        if (left == -1) return -1;
        int right = getDepth(root.right);
        if (right == -1) return -1;
        
        return Math.abs(left - right) > 1 ? -1 : 1 + Math.max(left, right);
    }
}
```



#### 	[257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

``` java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();
        if (root == null) return res;
        List<Integer> path = new ArrayList<>();

        traversal(root, res, path);

        return res;
    }

    // 递归 回溯
    public void traversal(TreeNode root, List<String> res, List<Integer> path) {
        path.add(root.val);

        // 终止条件
        if (root.left == null & root.right == null) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < path.size() - 1; i++) {
                sb.append(path.get(i)).append("->"); // append操作效率高
            } 
            sb.append(path.get(path.size() - 1));
            res.add(sb.toString());
            return;
        }

        // 递归逻辑
        if (root.left != null) {
            traversal(root.left, res, path);
            path.remove(path.size() - 1); // 回溯
        }
        if (root.right != null) {
            traversal(root.right, res, path);
            path.remove(path.size() - 1); // 回溯
        }
        return;
    }
}
```



#### 	[404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

```` java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;

        int res = getLeftSum(root);

        return res;
    }

    public int getLeftSum(TreeNode root) {
        // root肯定不为空

        // 终止条件
        if (root.left == null && root.right == null) return 0;

        // 递归逻辑
        int res = 0;
        if (root.left != null) {
            if (root.left.left == null && root.left.right == null) {
                res += root.left.val;
            } else {
                res += getLeftSum(root.left);
            }
        }
        if (root.right != null) {
            res += getLeftSum(root.right);
        }

        return res;
    }
}
````

#### 	[513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

``` java
// 解法一
class Solution {
    int maxDepth = 0;
    int res = 0;
    public int findBottomLeftValue(TreeNode root) {
        traversal(root, 1);
        return res;
    }

    public void traversal(TreeNode root, int depth) {
        // 终止条件
        if (root == null) return;

        // 处理逻辑
        if (root.left == null && root.right == null) {
            if (depth > maxDepth) {
                maxDepth = depth;
                res = root.val;
            }
        }

        // 递归
        traversal(root.left, depth + 1);
        traversal(root.right, depth + 1);

        return;
    }
}

// 解法二
// 层序遍历
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        int res = 0;
        int maxDepth = 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        int depth = 0;
        while (!queue.isEmpty()) {
            depth++;
            if (depth > maxDepth) { // 本层开始，记录新值
                maxDepth = depth;
                res = queue.peek().val;
            }
            int size = queue.size();
            for (int i = 0; i < size; i++) { // 清除本层节点，放入下层节点
                TreeNode node = queue.poll();
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
        }
        return res;
    }
}
```



#### 	[112. 路径总和](https://leetcode.cn/problems/path-sum/)

``` java
// 寻找一条符合的路径，递归需要返回值，找到后立即返回
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) return false;

        return traversal(root, targetSum - root.val);
    }

    public boolean traversal(TreeNode root, int count) {
        // 终止条件
        if (root.left == null && root.right == null && count == 0) return true;

        // 递归逻辑
        boolean res;
        if (root.left != null) {
            res = traversal(root.left, count - root.left.val);
            if (res) return true;
        }
        if (root.right != null) {
            res = traversal(root.right, count - root.right.val);
            if (res) return true;
        }

        return false;
    }
}
```



#### 	[113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

``` java
// 寻找所有符合条件的路劲，不需要返回值
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        if (root == null) return res;
        path.add(root.val);
        traversal(root, targetSum - root.val);
        return res;
    }

    public void traversal(TreeNode root, int count) {
        if (root.left == null && root.right == null && count == 0) {
            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < path.size(); i++) {
                list.add(path.get(i));
            }
            res.add(list);
        }

        // 递归逻辑
        if (root.left != null) {
            path.add(root.left.val);
            traversal(root.left, count - root.left.val);
            path.remove(path.size() - 1);
        }
        if (root.right != null) {
            path.add(root.right.val);
            traversal(root.right, count - root.right.val);
            path.remove(path.size() - 1);
        }
        
        return;
    }
}
```



### 二叉树修改与构造

#### 	[106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

``` java
class Solution {
    Map<Integer, Integer> map = new HashMap<>();
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }

        return getTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);
    }

    public TreeNode getTree(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) {
        // 终止条件 左闭右闭
        if (inBegin > inEnd) return null;

        // 递归逻辑
        int rootIndex = map.get(postorder[postEnd]);
        TreeNode root = new TreeNode(inorder[rootIndex]);
        root.left = getTree(inorder, inBegin, rootIndex - 1, postorder, postBegin, postBegin + rootIndex - inBegin - 1);
        root.right = getTree(inorder, rootIndex + 1, inEnd, postorder, postBegin + rootIndex - inBegin, postEnd - 1);
        return root;
    }
}
```



#### 	[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

``` java
class Solution {
    Map<Integer, Integer> map = new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }

        return getTree(inorder, 0, inorder.length - 1, preorder, 0, preorder.length - 1);
    }

    public TreeNode getTree(int[] inorder, int inBegin, int inEnd, int[] preorder, int preBegin, int preEnd) {
        // 终止条件 左闭右闭
        if (inBegin > inEnd) return null;

        // 递归逻辑
        int rootIndex = map.get(preorder[preBegin]);
        TreeNode root = new TreeNode(inorder[rootIndex]);
        root.left = getTree(inorder, inBegin, rootIndex - 1, preorder, preBegin + 1, preBegin + rootIndex - inBegin);
        root.right = getTree(inorder, rootIndex + 1, inEnd, preorder, preBegin + rootIndex - inBegin + 1, preEnd);

        return root;
    }
}
```

#### 	[654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

``` java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return getTree(nums, 0, nums.length - 1);
    }

    // 根据给定数组构造最大二叉树
    public TreeNode getTree(int[] nums, int begin, int end) {
        // 终止条件
        if (begin > end) return null;

        // 递归逻辑
        int maxNum = -1, index = -1;
        for (int i = begin; i <= end; i++) {
            if (nums[i] > maxNum) {
                maxNum = nums[i];
                index = i;
            }
        }
        TreeNode root = new TreeNode(maxNum);
        root.left = getTree(nums, begin, index - 1);
        root.right = getTree(nums, index + 1, end);

        return root;
    }
}
```

#### 	[617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

``` java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        // 终止条件
        if (root1 == null) return root2;
        if (root2 == null) return root1;

        // 递归逻辑
        root1.val += root2.val;
        root1.left = mergeTrees(root1.left, root2.left);
        root1.right = mergeTrees(root1.right, root2.right);

        return root1;
    }
}
```

#### 

### 二叉搜索树性质

#### [700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

``` java
class Solution {
  	// 递归
    public TreeNode searchBST(TreeNode root, int val) {
        // 终止条件
        if (root == null || root.val == val) return root;

        // 递归逻辑
        if (root.val < val) return searchBST(root.right, val);
        if (root.val > val) return searchBST(root.left, val);
        return null;
    }
		
  	// 迭代
    public TreeNode searchBST(TreeNode root, int val) {
        TreeNode cur = root;
        while (cur != null && cur.val != val) {
            if (cur.val > val) cur = cur.left;
            else cur = cur.right;
        }
        
        return cur;
    }
}
```



#### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

``` java
class Solution {
    TreeNode pre = null;
    // 中序遍历
    public boolean isValidBST(TreeNode root) {
        // 终止条件
        if (root == null) return true;

        // 递归逻辑
        boolean left = isValidBST(root.left);
        if (pre != null && pre.val >= root.val) return false;
        pre = root; // 更新前一个节点指针, 用于后面比较

        boolean right = isValidBST(root.right);

        return left && right;
    }
}
```



#### [530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

``` java
class Solution {
    TreeNode pre = null;
    int minDef = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
        getMin(root);
        return minDef;
    }

    public void getMin(TreeNode root) {
        // 终止条件
        if (root == null) return;

        // 递归逻辑
        getMin(root.left);
        if (pre != null) minDef = Math.min(minDef, root.val - pre.val);
        pre = root; // 更新pre
        getMin(root.right);

        return;
    }
}
```



#### [501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

``` java
class Solution {
    
    List<Integer> set = new ArrayList<>(); // list 比set快很多
    TreeNode pre = null;
    int curCount = 0; // 当前众数count
    int preCount = 0; // 前一个众数的count
    public int[] findMode(TreeNode root) {
        getMode(root);
        int[] res = new int[set.size()];
        int index = 0;
        for (Integer i : set) {
            res[index++] = i;
        }
        return res;
    }

    public void getMode(TreeNode root) {
        // 终止条件
        if (root == null) return;

        // 递归逻辑
        getMode(root.left);
        if (pre == null) curCount = 1;
        else if (pre.val == root.val) curCount++;
        else curCount = 1;
        if (curCount == preCount) set.add(root.val);
        if (curCount > preCount) {
            set.clear();
            preCount = curCount;
            set.add(root.val);
        }
        pre = root;
        
        getMode(root.right);

        return;
    }
}
```



#### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

``` java
class Solution {
    // 后序遍历，查找最近公共祖先
    // 函数如果找到一个节点，则返回节点，如果找到公共的祖先则返回祖先，其他情况返回null
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 终止条件
        if (root == null || root == p || root == q) return root;

        // 递归逻辑
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        if (left == null) return right;
        if (right == null) return left;
        return root;
    }
}
```



#### [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

``` java
class Solution {
  	// 二叉搜索树 
  	// 找到位于中间的节点，该节点一定就是最近公共祖先
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p, q);
        if (p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right, p, q);
        return root;
    }
}
```



#### [701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

``` java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        // 终止条件
        if (root == null) return new TreeNode(val);

        // 递归逻辑
        if (root.val < val) root.right = insertIntoBST(root.right, val);
        if (root.val > val) root.left = insertIntoBST(root.left, val);

        return root;
    }
}
```



### 二叉搜索树的修改与改造

#### [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

``` java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        // 终止条件
        if (root == null) return root;
        
        if (root.val == key) {
            if (root.left == null && root.right == null) return null;
            if (root.left == null) return root.right;
            if (root.right == null) return root.left;
            TreeNode node = root.right;
            while (node.left != null) {
                node = node.left;
            }
            node.left = root.left;
            return root.right;
        }

        // 递归删除逻辑
        if (root.val > key) root.left = deleteNode(root.left, key);
        if (root.val < key) root.right = deleteNode(root.right, key);

        return root;
    }
}
```



#### [669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)

``` java
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        // 终止条件
        if (root == null) return root;

        if (root.val < low) return trimBST(root.right, low, high);
        if (root.val > high) return trimBST(root.left, low, high);

        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);

        return root;
    }
}
```



#### [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

``` java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        TreeNode root = traversal(nums, 0, nums.length - 1);
        return root;
    }

    public TreeNode traversal(int[] nums, int begin, int end) {
        // 终止条件
        if (begin > end) return null;

        // 递归逻辑
        int mid = (begin + end) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = traversal(nums, begin, mid - 1);
        root.right = traversal(nums, mid + 1, end);
        return root;        
    }
}
```



#### [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

``` java
class Solution {
    TreeNode next = null;
    public TreeNode convertBST(TreeNode root) {
        traversal(root);
        return root;
    }
		
  	// 递归中序遍历，通过next指向后一个节点
    public void traversal(TreeNode root) {
        // 终止条件
        if (root == null) return;

        // 递归逻辑
        traversal(root.right);
        if (next != null) {
            root.val = next.val + root.val;
        }
        next = root;
        traversal(root.left);
        return;
    }
}
```



## 8. 回溯(15)

回溯本质是一种搜索算法，遍历解空间，找到目标解

回溯同时是递归的副产品，有递归就有回溯

### 组合问题

#### [77. 组合](https://leetcode.cn/problems/combinations/)√

``` java
class Solution {
    List<Integer> path = new ArrayList<>(); // 存放路径
    List<List<Integer>> res = new ArrayList<>(); // 存放结果

    public void backtracking(int n, int k, int start) { // start表示从哪里开始选下一个数
        if (path.size() == k) { // 满足条件
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = start; i <= n - k + path.size() + 1; i++) { //当剩下的数字不够选的时候直接剪枝
            path.add(i);
            backtracking(n, k, i + 1);
            path.remove(path.size() - 1);
        }
    }

    public List<List<Integer>> combine(int n, int k) {
        backtracking(n, k, 1);
        return res;
    }
}
```



#### [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)√

``` java
class Solution {
    List<Integer> path = new ArrayList<>(); // 路径
    List<List<Integer>> res = new ArrayList<>(); // 结果

    public void backtracking(int n, int k, int start, int sum) {
        if (sum >= n) { // 剪枝
            if (sum == n && path.size() == k) {
                res.add(new ArrayList<>(path));
            }
            return;
        }

        for (int i = start; i <= 9 - k + path.size() + 1; i++) {
            path.add(i);
            backtracking(n, k, i + 1, sum + i);
            path.remove(path.size() - 1);
        }
    }

    public List<List<Integer>> combinationSum3(int k, int n) {
        backtracking(n, k, 1, 0);
        return res;
    }
}
```



#### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

``` java
class Solution {
    List<String> res = new ArrayList<>();
    char[] path = new char[5];
    String[] numString = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};

    public void backtracking(String digits, int start) { //start代表当前要遍历第几层, 本质上就是需要告诉下一层，遍历的集合怎么找
        if (start == digits.length()) {
            res.add(new String(path, 0, start));
            return;
        }

        String string = numString[digits.charAt(start) - '0'];
        for (int i = 0; i < string.length(); i++){
            path[start] = string.charAt(i);
            backtracking(digits, start + 1);
        }
    }

    public List<String> letterCombinations(String digits) { 
        if (digits.length() == 0) return res;
        backtracking(digits, 0);
        return res;
    }
}
```



#### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

``` java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public void backtracking(int[] candidates, int startIndex, int sum, int target) {
        // 递归终止条件
        if (sum > target) return;
        if (sum == target) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = startIndex; i < candidates.length; i++) {
            path.add(candidates[i]);
            backtracking(candidates, i, sum + candidates[i], target); // 下一层任然从i处循环，即可实现重复选择
            path.remove(path.size() - 1);
        }
    }

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backtracking(candidates, 0, 0, target);
        return res;
    }
}
```



#### [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

``` java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public void backtracking(int[] candidates, int sum, int target, int startIndex) {
        if (sum == target) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = startIndex; i < candidates.length && (sum + candidates[i] <= target); i++) { // 剪枝
            if (i > startIndex && candidates[i - 1] == candidates[i]) continue; // 同层去重， 当i==startIndex时，是同支选择

            path.add(candidates[i]);
            backtracking(candidates, sum + candidates[i], target, i + 1);
            path.remove(path.size() - 1);
        }
    }

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates); // 数组排序是去重的关键
        backtracking(candidates, 0, target, 0); // 从candidates里选择，开始位置是0， 当前和为0， 目标为target
        return res;
    }
}
```

### 切割问题

#### [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

``` java
class Solution {
    List<List<String>> res = new ArrayList<>();
    List<String> path = new ArrayList<>();

    public void backtracking(String ss, char[] s, int startIndex) { // startIndex表示当前切割的这段字符的起点
        if (startIndex >= s.length) { // 片段开始起点大于s结尾的时候，说明已经切割完成
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = startIndex; i < s.length; i++) { // i表示这段切割字符的终点， 所以i可以==startIndex
            if (!isPalindrome(s, startIndex, i)) continue;
            path.add(ss.substring(startIndex, i + 1));
            backtracking(ss, s, i + 1);
            path.remove(path.size() - 1);
        }
    }

    public boolean isPalindrome(char[] s, int start, int end) {
        while (start <= end) {
            if (s[start++] != s[end--]) return false;
        }
        return true;
    }

    public List<List<String>> partition(String s) {
        char[] ss = s.toCharArray();
        backtracking(s, ss, 0); 
        return res;
    }
}
```



#### [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

``` java
class Solution {
    List<String> res = new ArrayList<>();
    char[] path = new char[100];

    public void backtrack(char[] s, int startIndex, int pointNum, int pathEnd) { // 
        if (pointNum == 3) { // 终止条件
            if (!isValid(s, startIndex, s.length - 1)) return;
            for (int i = startIndex; i < s.length; i++) path[++pathEnd] = s[i];
            res.add(new String(path, 0, pathEnd + 1));
        }

        int temp = pathEnd;
        for (int i = startIndex; i <= startIndex + 2 && i < s.length; i++) { // 剪枝
            if (!isValid(s, startIndex, i)) continue;
            for (int j = startIndex; j <= i; j++) path[++temp] = s[j];
            path[++temp] = '.';
            backtrack(s, i + 1, pointNum + 1, temp);
            temp = pathEnd; // 回溯
        }
    }

    public boolean isValid(char[] s, int start, int end) { // 合法性判断
        if (start > end || end - start > 2 || s.length <= start) return false; 
        if (s[start] == '0' && start != end) return false;
        int sum = 0;
        for (int i = start; i <= end; i++) {
            sum = sum * 10 + (s[i] - '0');
            if (sum > 255) return false;
        }
        return true;
    }

    public List<String> restoreIpAddresses(String s) {
        char[] ss = s.toCharArray();
        backtrack(ss, 0, 0, -1);
        return res;
    }
}
```



### 子集问题

组合与分割问题是找搜索树的叶子节点，子集问题是找所有节点

#### [78. 子集](https://leetcode.cn/problems/subsets/)

``` java
class Solution {
    // 找出所有子集，即为整个搜索树的所有节点
    // 组合问题，和切割问题，是找搜索树的叶子节点
    // 这两种搜索树其实都是根据一种思想得来：怎么找所有的组合，在单纯的组合问题中，k个位置的放置方法抽象出来是一颗搜索树；切割问题中，分割成k段的分割方法抽象出来也是一颗搜索树
    
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public void backtrack(int[] nums, int startIndex) {
        res.add(new ArrayList<>(path));

        for (int i = startIndex; i < nums.length; i++) {
            path.add(nums[i]);
            backtrack(nums, i + 1);
            path.remove(path.size() - 1);
        }
    }
        
    public List<List<Integer>> subsets(int[] nums) {
        backtrack(nums, 0);
        return res;
    }
}
```



#### [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)

``` java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public void backtrack(int[] nums, int startIndex) {
        res.add(new ArrayList<>(path));

        for (int i = startIndex; i < nums.length; i++) {
            if (i > startIndex && nums[i] == nums[i - 1]) continue; // 同层去重
            path.add(nums[i]);
            backtrack(nums, i + 1);
            path.remove(path.size() - 1);
        }
    }

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        backtrack(nums, 0);
        return res;
    }   
}
```



#### [491. 递增子序列](https://leetcode.cn/problems/non-decreasing-subsequences/)

``` java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public void backtrack(int[] nums, int startIndex, int preNum) {
        if (path.size() >= 2) res.add(new ArrayList<>(path)); // 找到所有的节点

        for (int i = startIndex; i < nums.length; i++) {
            if (nums[i] < preNum) continue; // 剪枝
            if (isRepeat(nums, startIndex, i)) continue; // 同层去重
            path.add(nums[i]);
            backtrack(nums, i + 1, nums[i]);
            path.remove(path.size() - 1);
        } 
    }

    public boolean isRepeat(int[] nums, int start, int end) { // 判重逻辑，在同层中，在该位置之前是否有重复
        for (int i = start; i < end; i++) {
            if (nums[i] == nums[end]) return true;
        }
        return false;
    }

    public List<List<Integer>> findSubsequences(int[] nums) {
        backtrack(nums, 0, -1000);
        return res;
    }
}
```



### 排列问题

#### [46. 全排列](https://leetcode.cn/problems/permutations/)

``` java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public void backtrack(int[] nums, int[] used, int choosedNum) {  // used 数组用来标记是否使用过， 与组合问题不同的是，排列问题中集合里的每一个数都要用到
        if (choosedNum == nums.length) { // 所以在确定下一层即下一个位置放置谁时，需要用used数组来去重；核心思路都一样，都是确定下一层的可选范围
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (used[i] == 1) continue;
            used[i] = 1;
            path.add(nums[i]);
            backtrack(nums, used, choosedNum + 1);
            used[i] = 0;
            path.remove(path.size() - 1);
        }
    }

    public List<List<Integer>> permute(int[] nums) {
        int[] used = new int[nums.length];
        backtrack(nums, used, 0);
        return res;
    }
}
```



#### [47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)

``` java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public void backtrack(int[] nums, int[] used) {
        if (path.size() == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (used[i] == 1) continue;
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == 0) continue; // 如果当前i没有用过，而且它前面一个数同样没有，那么他们属于同一层，所以需要同层去重
            used[i] = 1;
            path.add(nums[i]);
            backtrack(nums, used);
            path.remove(path.size() - 1);
            used[i] = 0;
        }
    }

    public List<List<Integer>> permuteUnique(int[] nums) {
        int[] used = new int[nums.length];
        Arrays.sort(nums);
        backtrack(nums, used);
        return res;
    }
}
```



### 棋盘问题

#### [51. N 皇后](https://leetcode.cn/problems/n-queens/)

``` java
class Solution {
    List<List<String>> res = new ArrayList<>();

    public void backtrack(int n, int row, char[][] board) { // 核心点在于，理解搜索树上每一个节点是什么，每一层遍历的状态是怎么确定的
        if (row == n) {
            List<String> path = new ArrayList<>();
            // for (char[] c : board) path.add(String.copyValueOf(c));
            // for (int i = 0; i < n; i++) path.add(String.copyValueOf(board[i]));
            for (int i = 0; i < n; i++) path.add(new String(board[i]));
            res.add(path);
            return;
        }

        for (int i = 0; i < n; i++) {
            if (!isValid(n, row, i, board)) continue;
            board[row][i] = 'Q';
            backtrack(n, row + 1, board);
            board[row][i] = '.';
        }
    }

    public boolean isValid(int n, int row, int col, char[][] board) {
        // 检查列
        for (int i = 0; i < n; i++) {
            if (board[i][col] == 'Q') return false;
        }

        // 斜角
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; j--, i--) { 
            if (board[i][j] == 'Q') return false;
        }

        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board[i][j] == 'Q') return false;
        }
        return true;
    }

    public List<List<String>> solveNQueens(int n) {
        char[][] board = new char[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) board[i][j] = '.';
        }
        // for (char[] i : board) Arrays.fill(i, '.');
        backtrack(n, 0, board);
        return res;
    }
}
```



#### [37. 解数独](https://leetcode.cn/problems/sudoku-solver/)

``` java
class Solution {
    public boolean backtrack(char[][] board) {
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) { // 遍历所有的可填充位置
                if (board[i][j] != '.') continue;
                for (char k = '1'; k <= '9'; k++) {
                    if (isValid(board, i, j, k)) {
                        board[i][j] = k;
                        if (backtrack(board)) return true; // 如果当前搜索状态，往下找到了合法的解，则直接返回
                        board[i][j] = '.';
                    }
                }
                return false; // 对于当前搜索状态来说，不存在合法的解，直接向上返回
            }
        }
        return true; // 当整个棋盘没有位置可以填充时，即找到可行解，向上返回true
    }

    public boolean isValid(char[][] board, int i, int j, char k) {
        for (int x = 0; x < 9; x++) {
            if (board[x][j] == k) return false;
        }

        for (int y = 0; y < 9; y++) {
            if (board[i][y] == k) return false;
        }

        int a = (i / 3) * 3, b = (j / 3) * 3;
        for (int x = a; x < a + 3; x++) {
            for (int y = b; y < b + 3; y++) {
                if (board[x][y] == k) return false;
            }
        }
        
        return true;
    }

    public void solveSudoku(char[][] board) {
        backtrack(board);
    }
}
```

 

#### [332. 重新安排行程](https://leetcode.cn/problems/reconstruct-itinerary/)

```` java
class Solution {
    List<String> res = new ArrayList<>();

    public boolean backtrack(Map<String, Map<String, Integer>> map, int num, String from) {
        if (res.size() == num + 1) return true; // 所有形成全部走完

        Map<String, Integer> temp = map.get(from);
        if (temp == null) return false;
        for (Map.Entry<String, Integer> target : temp.entrySet()) {
            int count = target.getValue();
            if (count <= 0) continue;
            temp.put(target.getKey(), count - 1);
            res.add(target.getKey());
            if (backtrack(map, num, target.getKey())) return true; // 找到解就返回
            temp.put(target.getKey(), count);
            res.remove(res.size() - 1);
        }
        return false;
    } 

    public List<String> findItinerary(List<List<String>> tickets) {
        Map<String, Map<String, Integer>> map = new HashMap<>();
        for (List<String> ticket : tickets) {
            Map<String, Integer> temp;
            if (map.containsKey(ticket.get(0))) {
                temp = map.get(ticket.get(0));
                temp.put(ticket.get(1), temp.getOrDefault(ticket.get(1), 0) + 1);
            } else {
                temp = new TreeMap<>(); // 需要返回最小排序，所以对出发节点要排序，这样只要找到解，就是最小排序
                temp.put(ticket.get(1), 1);
                map.put(ticket.get(0), temp);
            }
        }
        res.add("JFK");
        backtrack(map, tickets.size(), "JFK"); // 从该节点出发向下搜索， 从该机场出发
        return res;
    }
}
````



## 9. 贪心(18)

#### [455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)

```` java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int res = 0;
        int index = 0;
        for (int i = 0; i < g.length && index < s.length; i++) { // 优先考虑饼干，小饼干先满足小胃口
            while (index < s.length && g[i] > s[index]) index++; // 找到最小的满足胃口的饼干
            if (index < s.length) {
                res++;
                index++;
            }
        }
        return res;
    }
}
````



#### [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

局部最优=>全部最优：将局部波峰波谷中的序列中的无效节点删除即可

``` java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if (nums.length <= 1) return nums.length;
        int res = 1; // 至少开始节点是一个
        int prediff = 0, nextdiff = 0;
        for (int i = 0; i < nums.length - 1; i++) {
            nextdiff = nums[i + 1] - nums[i];
            if ((prediff <= 0 && nextdiff > 0) || (prediff >= 0 && nextdiff < 0)) { // 处理波峰和波谷平坡
                res++;
                prediff = nextdiff; // 处理单调序列中的平坡
            }
        }
        return res;
    }
}
```



#### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

``` java
class Solution {
    public int maxSubArray(int[] nums) {
        int res = Integer.MIN_VALUE;
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            count += nums[i];
            if (count > res) res = count; // 更新当前区间求和的最大值
            if (count < 0) count = 0; // 当区间和为负数时，直接跳过，会影响后面最大值，贪心策略
        }
        return res;
    }
}
```



#### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

``` java
class Solution {
    public int maxProfit(int[] prices) { // 找到每一对波谷和波峰求差值
        if (prices.length <= 1) return 0;
        int res = 0;
        int preLow = -1;
        int prediff = -1; // 下坡
        for (int i = 0; i < prices.length - 1; i++) {
            if (prices[i + 1] - prices[i] > 0 && prediff < 0) { // 波谷
                preLow = prices[i]; // 记录局部最小价格
                prediff = 1; // 上坡
                continue;
            }
            if (prices[i + 1] - prices[i] < 0 && prediff > 0) { // 波谷之后的第一个波峰，出手赚取该区间内的最大差值
                res += prices[i] - preLow;
                prediff = -1;
                preLow = -1;
            }
        }
        if (prediff > 0) { // 结束时，最后一个节点是上升状态
            res += prices[prices.length - 1] - preLow;
        }
        return res;
    }
}
```



```` java
class Solution {
    public int maxProfit(int[] prices) { // 波峰和波谷之间的差值可以分解成两两差值
        int res = 0;
        for (int i = 1; i < prices.length; i++) {
            res += prices[i] - prices[i - 1] > 0 ? prices[i] - prices[i - 1] : 0;
        }
        return res;
    }
}
````



#### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

``` java
class Solution {
    // 贪心
    public int maxProfit(int[] prices) {
        int low = prices[0], res = 0; // low表示到目前为止的最低价格
        for (int i = 0; i < prices.length; i++) {
            low = Math.min(prices[i], low);
            res = Math.max(res, prices[i] - low);
        }

        return res;
    }
}
```



#### [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

``` java
class Solution {
    public boolean canJump(int[] nums) {
        int max = 0;
        for (int i = 0; i <= max; i++) { // 每次遍历可跳范围，找最大范围
            max = Math.max(max, i + nums[i]);
            if (max >= nums.length - 1) return true;
        }
        return false;
    }
}
```



#### [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

``` java
class Solution {
    public int jump(int[] nums) {
        if (nums.length == 1) return 0;
        int res = 1;
        int max = 0, temp = 0;
        for (int i = 0; i < max + 1; i++) {
            temp = Math.max(temp, nums[i] + i);
            if (temp > nums.length - 2) return res; // 局部最优策略：每次跳跃幅度都最大
            if (i == max) {
                max = temp;
                res++;
            }
        }
        return res;
    }
}
```



#### [1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

``` java
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) { // 局部最优策略：先将负数翻转，剩下的翻转绝对值小的那个
        Arrays.sort(nums);
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            if (k > 0) {
                if (nums[i] < 0) {
                    res += nums[i] * -1;
                    k--;
                } else {
                    if (k % 2 == 0) res += nums[i];
                    else if (i - 1 >= 0){
                        res -= nums[i - 1] * -1;
                        res += (nums[i - 1] * -1) < nums[i] ? nums[i - 1] + nums[i] : nums[i - 1] * -1 - nums[i]; 
                    } else {
                        res += nums[i] * -1;
                    }
                    k = 0;
                }
                continue;
            }
            res += nums[i];
        }
        if (k > 0 && k % 2 == 1) {
            res += nums[nums.length - 1] * 2;
        }
        return res;
    }
}
```



#### [134. 加油站](https://leetcode.cn/problems/gas-station/)

``` java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int res = 0;
        int sum = 0;
        int start = 0;
        for (int i = 0; i < gas.length; i++) { // 局部最优策略：连续字段如果和大于0，则有可能连通，sum小于0一定不行
            res += gas[i] - cost[i];
            sum += gas[i] - cost[i];
            if (res < 0) {
                res = 0;
                start = i + 1;
            }
        }
        if (sum < 0) return -1;
        return start;
    }
}
```



#### [135. 分发糖果](https://leetcode.cn/problems/candy/)

``` java
class Solution {
    public int candy(int[] ratings) {
        int[] candys = new int[ratings.length];
        int res = 0;
        // 从左边往右边发
        candys[0] = 1;
        for (int i = 1; i < ratings.length; i++) {
            candys[i] = ratings[i] > ratings[i - 1] ? candys[i - 1] + 1 : 1;
        }

        // 从右往左发
        res += candys[ratings.length - 1];
        for (int i = ratings.length - 2; i >= 0; i--) {
            candys[i] = (ratings[i] > ratings[i + 1]) && (candys[i] <= candys[i + 1]) ? candys[i + 1] + 1 : candys[i];
            res += candys[i];
        }

        return res;
    }
}
```



#### [860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)

``` java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int m5 = 0, m10 = 0, m20 = 0;
        for (int i = 0; i < bills.length; i++) {
            if (bills[i] == 5) {
                m5++;
                continue;
            }
            if (bills[i] == 10) {
                m10++;
                if (m5 > 0) {
                    m5--;
                    continue;
                }
                return false;
            }
            if (bills[i] == 20) {
                m20++;
                if (m10 > 0 && m5 > 0)  // 局部最优：先用10块
                    m10--;
                    m5--;
                    continue;
                }
                if (m5 > 2) { // 不行再用5块
                    m5 -= 3;
                    continue;
                }
                return false;
            }
        }
        return true;
    }
}
```



#### [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

``` java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, (a, b) -> { // 根据身高从大到小排序，再根据次数从小到大排
            if (a[0] == b[0]) return a[1] - b[1]; // 小排前 a - b
            else return b[0] - a[0]; // 大排前 b - a
        });

        ArrayList<int[]> res = new ArrayList<>(); 
        for (int[] p : people) { // 这样将后面顺序的不对的往前插就可以了
            res.add(p[1], p);
        }
        
        return res.toArray(new int[people.length][]);
    }
}
```



#### [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

``` java
class Solution {
    public int findMinArrowShots(int[][] points) {
        Arrays.sort(points, (a, b) -> Integer.compare(a[0], b[0]));
        
        int res = 1;
        int end = points[0][1];
        for (int i = 1; i < points.length; i++) {
            if (points[i][0] > end) {
                res++;
                end = points[i][1]; // 更新下一次区间最右侧区间
                continue;
            }
            if (points[i][0] <= end) {
                end = Math.min(end, points[i][1]); // 更新本次重叠区间最右侧区间
                continue;
            }
        }
        return res;
    }
}
```



#### [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

``` java
class Solution {
    // public int eraseOverlapIntervals(int[][] intervals) {
    //     Arrays.sort(intervals, (a, b) -> {
    //         // if (a[0] == b[0]) return a[1] - b[1]; // 返回值大于0 就交换
    //         return a[0] - b[0];
    //     });

    //     int res = 1;
    //     int end = intervals[0][1];
    //     for (int i = 1; i < intervals.length; i++) {
    //         if (intervals[i][0] > end - 1) { // 当前块左边界大于上个区块，数量加一
    //             res++;
    //             end = intervals[i][1]; // 更新下区块右边界
    //         } else {
    //             end = end > intervals[i][1] ? intervals[i][1] : end;
    //             // intervals[i][1] = intervals[i - 1][1] > intervals[i][1] ? intervals[i][1] : intervals[i - 1][1];
    //         }
    //     }

    //     return intervals.length - res;
    // }

    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> { // 对右侧区间排序后，只需要从左侧区间开始找，右侧区间和左侧区间不重合的即可
            return a[1] - b[1]; 
        });

        int res = 1;
        int end = intervals[0][1];
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] >= end) {
                res++;
                end = intervals[i][1];
            }
        }
        return intervals.length - res;
    }
}
```



#### [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

``` java
class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> res = new ArrayList<>();

        char[] ss = s.toCharArray();
        int end = 0, preEnd = -1;
        while (end < ss.length) {
            for (int i = end; i <= end; i++) { // 本轮循环找到当前字符的最远边界
                for (int j = i + 1; j < ss.length; j++) {
                    if (ss[j] == ss[i]) end = j > end ? j : end;
                }
            }
            res.add(end - preEnd);
            preEnd = end;
            end++;
        }
        return res;
    }
}
```





#### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

``` java
class Solution {
    public int[][] merge(int[][] intervals) {
        ArrayList<int[]> res = new ArrayList<>();
        Arrays.sort(intervals, (a, b) -> {
            if (a[0] == b[0]) return b[1] - a[1];
            return a[0] - b[0];
        });

        int start = intervals[0][0], end = intervals[0][1];
        for (int i = 1; i < intervals.length; i++) { // 按左边界排序
            if (intervals[i][0] > end) { // 更新区间
                res.add(new int[]{start, end});
                start = intervals[i][0];
                end = intervals[i][1];
            } else {
                end = intervals[i][1] > end ? intervals[i][1] : end; // 更新有边界
            }
        }
        res.add(new int[]{start, end});
        return res.toArray(new int[res.size()][]);
    }
}
```



#### [738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)

``` java
class Solution {
    public int monotoneIncreasingDigits(int n) {
        int[] res = new int[12];
        int index = 0;
        while (n > 0) {
            res[index++] = n % 10;
            n = n / 10;
        }
        int sum = 0;
        int flag = -1;
        for (int i = 0; i < index - 1; i++) {
            if (res[i] < res[i + 1]) { // 当后面数小于前面数的时候, 这个数为9，则这个数后面的数都为9， 前面数减一即可
                flag = i;
                res[i + 1] = res[i + 1] - 1;
            }
        }
        for (int i = index - 1; i >= 0; i--) {
            if (i <= flag) {
                sum = sum * 10 + 9;
            } else {
                sum = sum * 10 + res[i];
            }
        }
        return sum;
    }
}
```



#### [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)

``` java
class Solution {
    int res = 0;

    public int traversal(TreeNode root) {
        if (root == null) return 2; // 子节点有覆盖
        int left = traversal(root.left);
        int right = traversal(root.right);

        if (left == 2 && right == 2) return 0; // 左右节点都有覆盖,本层无需放摄像头
        if (left == 0 || right == 0) { // 0表示子节点有无覆盖的，所以本层必须放摄像头
            res++;
            return 1;
        }
        if (left == 1 || right == 1) return 2; // 1表示子节点有摄像头，则本层是有覆盖

        return -1;
    }

    public int minCameraCover(TreeNode root) {
        if (traversal(root) == 0) res++;
        return res;
    }
}
```

  

## 10. 动态规划(36)

动态规划五部曲：

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

### 基础题目

#### [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

``` java
class Solution {
    public int fib(int n) {
        int[] dp = new int[n + 2]; // dp[i] 表示第i个数的值
        // 确定地推公式: dp[i] = dp[i - 1] + dp[i - 2];
        dp[0] = 0;
        dp[1] = 1; // dp数组初始化
        // 确定遍历顺序: 从左到右
        // 举例模拟
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```



#### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

``` java
class Solution {
    public int climbStairs(int n) {
        // dp[n]: 表示爬到n阶时的方法数量
        // dp[n] = dp[n - 2] + dp[n - 1] n阶的方法数量可以用n-2和n-1阶的和的数量来计算
        // 初始化 dp[1] = 1, dp[2] = 2;
        // 遍历顺序，从左到右
        int[] dp = new int[n + 2];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }
}
```



#### [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

``` java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        // dp[i] : 到第i个楼梯时，最小花费体力值
        // dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2] + dp[i - 1]);
        // dp[0] = 0, dp[1] = 0;
        int[] dp = new int[cost.length + 2];
        dp[0] = 0;
        dp[1] = 0;
        for (int i = 2; i <= cost.length; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        
        return dp[cost.length];
    }
}
```



#### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

``` java
class Solution {
    public int uniquePaths(int m, int n) {
        // dp[m][n]: 到m，n的路径总和
        // dp[m][n] = dp[m - 1][n] + dp[m][n - 1]
        // dp[0][n] = 0, dp[m][0] = 0
        // 从上往下，从左往右
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int i = 0; i < n; i++) dp[0][i] = 1;

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        return dp[m - 1][n - 1];
    }
}
```



#### [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

``` java
class Solution {
    public int uniquePathsWithObstacles(int[][] ob) {
        // dp[i][j]：从0,0 到i，j的路径方法和
        // dp[i][j] = ob[i][j] == 1 ？ 0 : dp[i - 1][j] + dp[i][j - 1];
        // dp[i][0] = 1 =》 dp[i][0] = 0, dp[0][j] = 1 =》 dp[0][j] = 0;
        int[][] dp = new int[ob.length][ob[0].length];
        dp[0][0] = ob[0][0] == 1 ? 0 : 1;
        for (int i = 1; i < ob.length; i++) {
            if (dp[i - 1][0] == 0) {
                dp[i][0] = 0;
                continue;
            } 
            dp[i][0] = ob[i][0] == 1 ? 0 : 1;
        }
        for (int i = 1; i < ob[0].length; i++) {
            if (dp[0][i - 1] == 0) {
                dp[0][i - 1] = 0;
                continue;
            } 
            dp[0][i] = ob[0][i] == 1 ? 0 : 1;
        }
        
        for (int i = 1; i < ob.length; i++) {
            for (int j = 1; j < ob[0].length; j++) {
                dp[i][j] = ob[i][j] == 1 ? 0 : dp[i - 1][j] + dp[i][j - 1];
            }
        }
        
        return dp[ob.length - 1][ob[0].length - 1];
    }
}
```



#### [343. 整数拆分](https://leetcode.cn/problems/integer-break/)

``` java
class Solution {
    public int integerBreak(int n) {
        // dp[i] : 整数i的和乘积最大值
        // dp[i] = for Max(dp[i], dp[j] * (i - j), j * (i-j))
        // dp[0] = 0, dp[1] = 1, dp[2] = 1
        int[] dp = new int[n + 2];
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 1;
        for (int i = 3; i <= n; i++) {
            dp[i] = 0;
            for (int j = 1; j < i; j++) dp[i] = Math.max(dp[i], Math.max(dp[j] * (i - j), j*(i - j)));
        }

        return dp[n];
    }
}
```



#### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

``` java
class Solution {
    public int numTrees(int n) {
        // dp[i]: i个节点的二叉搜索树种类
        // dp[i] += dp[j - 1] * dp[i - j] j(1, i)
        // dp[0] = 1, dp[1] = 1;
        int[] dp = new int[n + 2];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            } 
        }

        return dp[n];
    }
}
```



### 01背包问题

#### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

``` java
class Solution {
    // 原题：能否有一个集合，使得和等于所有元素和的一半
    // 转化：给定一个容积大小为和一半的背包，从数组中取数放入背包，因为数字的重量和价值相等，背包的最大价值不会超过其容积
    // 如果背包的最终最大价值==他的容积，说明数字刚好把背包填满，即数字的重量和刚好等于容积
    public boolean canPartition(int[] nums) {
        // dp[i]: 表示背包大小为i时，能够放下的数字和最大值
        // dp[i] = max(dp[i], dp[i - n   ums[j]] + nums[j]);
        int sum = 0;
        for (int i = 0; i < nums.length; i++) sum += nums[i];
        if (sum % 2 == 1) return false;

        int target = sum / 2; // 背包容量
        int[] dp = new int[target + 5];

        for (int i = 1; i <= nums.length; i++) {
            for (int j = target; j >= nums[i - 1]; j--) {
                dp[j] = Math.max(dp[j], dp[j - nums[i - 1]] + nums[i - 1]);
            }
        }
        if (dp[target] == target) return true;
        return false;
    }
}
```



#### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

``` java
class Solution {
    // 核心策略: 把石头分成两堆，使其重量尽可能相同，最后剩下的最少
    // 用大小为sum / 2 的背包来放石头，让石头的价值尽可能大，也就是重量尽可能大，无线逼近sum / 2
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int i = 0; i < stones.length; i++) sum += stones[i];

        int target = sum / 2;
        int[] dp = new int[target + 5];

        for (int i = 1; i < stones.length + 1; i++) {
            for (int j = target; j > stones[i - 1] - 1; j--) {
                dp[j] = Math.max(dp[j], dp[j - stones[i - 1]] + stones[i - 1]);
            }
        }

        return sum - dp[target] - dp[target];
    }
}
```



#### [494. 目标和](https://leetcode.cn/problems/target-sum/)

``` java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        // dp[i][j] : 从前i个数里取，和为j的方法总和
        // dp[i][j] = dp[i - 1][j] + dp[i - 1][j - num[i]]


        int sum = 0;
        for (int i = 0; i < nums.length; i++) sum += nums[i];
        sum = sum - target;
        if (sum < 0 || sum % 2 == 1) return 0;
        int X = sum / 2;
        int[] dp = new int[X + 5];
        dp[0] = 1; // 从前0个数里取，和为0
        for (int i = 1; i <= nums.length; i++) {
            for (int j = X; j >= nums[i - 1]; j--) {
                dp[j] = dp[j] + dp[j - nums[i - 1]];
            }
        }
        
        return dp[X];
    }
}
```



#### [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

``` java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        // dp[k][i][j] : 从前k个字符串里面选，0最多有i个，1最多有j个的集合的最大sizedp[i][j]

        int[][] dp = new int[m + 5][n + 5];
        for (int k = 1; k <= strs.length; k++) {
            int zeroNum = 0, oneNum = 0;
            for (int i = 0; i < strs[k - 1].length(); i++) {
                if (strs[k - 1].charAt(i) == '0') zeroNum++;
                else oneNum++;
            }

            for (int i = m; i >= zeroNum; i--) {
                for (int j = n; j >= oneNum; j--) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }

        return dp[m][n];
    }
}
```



### 完全背包问题

#### [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

``` java
class Solution {
    public int change(int amount, int[] coins) {
        // f[i][j]: 前i个硬币里面选，和为j的所有组合和
        // f[i][j] = f[i - 1][j] + f[i][j - c[i]]
        int[] dp = new int[amount + 5];
        dp[0] = 1;
        for (int i = 1; i <= coins.length; i++) {
            for (int j = coins[i - 1]; j <= amount; j++) {
                if (j >= coins[i - 1]) dp[j] += dp[j - coins[i - 1]];
            }
        }

        return dp[amount];
    }
}
```



#### [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

``` java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        // dp[i][j] : 从前i个数里面选，和为j的所有的组合数
        int[] dp = new int[target + 5];
        dp[0] = 1;
        for (int i = 0; i <= target; i++) { // 背包在外层，求的是排列数
            for (int j = 1; j <= nums.length; j++) {
                if (i >= nums[j - 1]) dp[i] += dp[i - nums[j - 1]];
            }
        }

        return dp[target];
    }
}
```



#### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

```` java
class Solution {
    public int coinChange(int[] coins, int amount) { // 完全背包，组合类型
        // dp[j]: 和为j的需要的硬币的最小个数
        // dp[j] = min(dp[j - coins[i] + 1, dp[j]])

        int[] dp = new int[amount + 5];
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) dp[i] = Integer.MAX_VALUE;
        for (int i = 1; i <= coins.length; i++) {
            for (int j = coins[i - 1]; j <= amount; j++) {
                if (dp[j - coins[i - 1]] == Integer.MAX_VALUE) continue;
                dp[j] = Math.min(dp[j], dp[j - coins[i - 1]] + 1);
            }
        }

        if (dp[amount] == Integer.MAX_VALUE) return -1;
        return dp[amount];
    }
}
````



#### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

``` java
class Solution {
    public int numSquares(int n) { // 完全背包+组合数
        // dp[i]: 完全平方数和为i的最少数量
        // dp[i] = min(dp[i - j] + 1, dp[i])

        int[] dp = new int[n + 5];
        dp[0] = 0;
        for (int i = 1; i <= n; i++) dp[i] = Integer.MAX_VALUE;
        for (int i = 1; i * i <= n; i++) { // 物品
            for (int j = i * i; j <= n; j++) { // 背包
                if (dp[j - i * i] == Integer.MAX_VALUE) continue;
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
            }
        }
        
        return dp[n];
    }
}
```



#### [139. 单词拆分](https://leetcode.cn/problems/word-break/)

```` java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        // 完全背包，排列类型
        // dp[i][j]: 从前i个单词中选，组合到第j个字符，能否组成
        // dp[i][j] = dp[i - 1][j] || dp[i - 1][j - s[i]]
        boolean[] dp = new boolean[s.length() + 5];
        dp[0] = true;
        // for (int i = 1; i <= wordDict.size(); i++) { //遍历背包物品
        //     int len = wordDict.get(i - 1).length();
        //     for (int j = len; j <= s.length(); j++) { // 容积
        //         if (s.substring(j - len, j - 1).equals(wordDict.get(i - 1))) continue;
        //         dp[j] = dp[j] || dp[j - len];
        //     }
        // }

        for (int j = 1; j <= s.length(); j++) {
            for (int i = 1; i <= wordDict.size(); i++) {
                int len = wordDict.get(i - 1).length();
                if (j < len) continue;
                if (s.substring(j - len, j).equals(wordDict.get(i - 1)) && dp[j - len]) { // 只要有任意一种情况，可以拼成字符，当前dp[j]就为true
                    dp[j] = true;
                } 
            }
        }
        
        return dp[s.length()];
    }
}
````



### 打家劫舍

#### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

``` java
class Solution {
    public int rob(int[] nums) {
        // dp[i]: 到第i个房间，偷到的最大金额
        // dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
        if (nums.length == 1) return nums[0];
        int[] dp = new int[nums.length + 5];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }

        return dp[nums.length - 1];
    }
}
```





#### [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

``` java
class Solution {
    public int rob(int[] nums) { // 考虑三种情况，首尾不偷，首偷尾不偷，首不偷尾偷，第一种被包含在第二三种里面
        if (nums.length == 1) return nums[0];
        return Math.max(getMax(nums, 0, nums.length - 2), getMax(nums, 1, nums.length - 1)); 
    }

    public int getMax(int[] nums, int start, int end) {
        if (end == start) return nums[start];
        int[] dp = new int[nums.length];
        dp[0] = nums[start];
        dp[1] = Math.max(nums[start], nums[start + 1]);
        for (int i = 2; i < end - start + 1; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[start + i], dp[i - 1]);
        }

        return dp[end - start];
    }
}
```



#### [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/) 

树形dp

``` java
class Solution {
    public int rob(TreeNode root) {
        // 树形dp
        int[] res = getMax(root);
        return Math.max(res[0], res[1]);
    }

    public int[] getMax(TreeNode root) { // dp[0]表示当前节点不偷的最大值，dp[1]表示当前节点偷的最大值
        if (root == null) return new int[]{0, 0};

        // 获取左右节点的状态
        int[] leftDp = getMax(root.left);
        int[] rightDp = getMax(root.right);

        int[] rootDp = new int[2];
        rootDp[0] = Math.max(leftDp[0], leftDp[1]) + Math.max(rightDp[0], rightDp[1]); // 当前节点不偷
        rootDp[1] = leftDp[0] + rightDp[0] + root.val; // 当前节点偷

        return rootDp;
    }
}
```



### 股票问题

#### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

```` java
class Solution {
    // 贪心
    public int maxProfit(int[] prices) {
        int low = prices[0], res = 0; // low表示到目前为止的最低价格
        for (int i = 0; i < prices.length; i++) {
            low = Math.min(prices[i], low);
            res = Math.max(res, prices[i] - low);
        }

        return res;
    }
}
````

``` java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length == 1) return 0;
        // dp[i][0]: 第i天持有股票的收获的最大价值
        // dp[i][1]: 第i天不持有股票收获的最大价值
        int[][] dp = new int[prices.length][2];
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        
        return dp[prices.length - 1][1];
    }
}
```



#### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

``` java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length == 1) return 0;
        // dp[i][0]: 第i天持有股票的收获的最大价值
        // dp[i][1]: 第i天不持有股票收获的最大价值
        int[][] dp = new int[prices.length][2];
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] -prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        
        return dp[prices.length - 1][1];
    }
}
```



#### [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

``` java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length == 1) return 0;
        // dp[i][0]: 无操作状态
        // dp[i][1]: 第一次操作持有股票的最大价值
        // dp[i][2]: 第一次操作不持有股票的最大价值
        // dp[i][3]: 第二次操作持有股票的最大价值
        // dp[i][4]: 第二次操作不持有股票的最大价值
        int[][] dp = new int[prices.length][5];
        dp[0][0] = 0;
        dp[0][1] -= prices[0];
        dp[0][2] = 0;
        dp[0][3] -= prices[0];
        dp[0][4] = 0;

        for (int i = 1; i < prices.length; i++) {
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }

        return Math.max(dp[prices.length - 1][2], dp[prices.length - 1][4]);
    }
}
```



#### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

``` java
class Solution {
    public int maxProfit(int k, int[] prices) {
        if (prices.length <= 1 || k == 0) return 0;

        // dp[i][2 * k - 1]: 第k次操作最后持有股票的最大价值
        // dp[i][2 * k]: 第k次操作最后不持有股票的最大价值
        int[][] dp = new int[prices.length][2 * k + 1];
        for (int i = 1; i <= k; i++) {
            dp[0][2 * i - 1] -= prices[0];
        }

        for (int i = 1; i < prices.length; i++) {
            for (int j = 1; j <= k; j++) {
                dp[i][2 * j - 1] = Math.max(dp[i - 1][2 * j - 1], dp[i - 1][2 * j - 2] - prices[i]);
                dp[i][2 * j] = Math.max(dp[i - 1][2 * j], dp[i - 1][2 * j - 1] + prices[i]);
            }
        }

        int res = 0;
        for (int i = 1; i <= k; i++) {
            res = Math.max(res, dp[prices.length - 1][2 * i]);
        }

        return res;
    }
}
```



#### [309. 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

``` java
class Solution {
    public int maxProfit(int[] prices) {
        // dp[i][0]: 第i天达到买入股票状态的最大价值
        // dp[i][1]: 第i天保持卖出股票状态的最大价值
        // dp[i][2]: 第i天卖出股票状态的最大价值
        // dp[i][3]: 第i天达到冷冻期的最大价值
        if (prices.length == 1) return 0;
        int[][] dp = new int[prices.length][4];
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        dp[0][2] = 0;
        dp[0][3] = 0;

        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], Math.max(dp[i - 1][1], dp[i - 1][3]) - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }

        return Math.max(dp[prices.length - 1][3], Math.max(dp[prices.length - 1][2], dp[prices.length - 1][1]));
    }
}
```



### 子序列问题

#### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

``` java
class Solution {
    public int lengthOfLIS(int[] nums) {
        // dp[i]: 以nums[i]结尾的最长上升子序列的长度
        // dp[i] = max(dp[i], dp[j] + 1) if nums[i] > nums[j];
        int[] dp = new int[nums.length];
        int res = 1;
        dp[0] = 1;
        for (int i = 1; i < nums.length; i++) {
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) dp[i] = dp[i] > dp[j] + 1 ? dp[i] : dp[j] + 1;
            }
            res = res > dp[i] ? res : dp[i];
        }

        return res;
    }
}
```



#### [674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

``` java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        // dp[i]: 以i结尾的最长连续上升子序列长度
        // dp[i] = dp[i - 1] + 1 if nums[i] > nums[i - 1];

        int res = 1;
        int[] dp = new int[nums.length];
        dp[0] = 1;
        for (int i = 1; i < nums.length; i++) {
            dp[i] = 1;
            if (nums[i] > nums[i - 1]) dp[i] = dp[i - 1] + 1;
            res = res > dp[i] ? res : dp[i];
        }

        return res;
    }
}
```



#### [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

``` java
class Solution {
    public int findLength(int[] nums1, int[] nums2) { // 连续的
        // dp[i][j]: 表示以nums1[i-1]，nums2[j-1]为结尾的最长重复连续子数组的长度
        // dp[i][j] = d[i - 1][j - 1] + 1 if (nums[i - 1] == nums[j - 1])
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];
        dp[0][0] = 0;
        int res = 0;
        for (int i = 1; i <= nums1.length; i++) {
            for (int j = 1; j <= nums2.length; j++) {
                if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                if (dp[i][j] > res) res = dp[i][j];
            }
        }

        return res;
    }
}
```



#### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

``` java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        // dp[i][j]: 以text1[i - 1],text2[j - 1]结尾的最长公共序列的长度
        // dp[i][j] = dp[i - 1][j - 1] + 1 if text1[i -1] == text2[j - 1] else max(dp[i - 1][j], dp[i][j - 1]) 
        int res = 0;
        char[] s1 = text1.toCharArray(), s2 = text2.toCharArray();
        int[][] dp = new int[s1.length + 1][s2.length + 1];
        for (int i = 1; i <= s1.length; i++) {
            for (int j = 1; j <= s2.length; j++) {
                if (s1[i - 1] == s2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                if (dp[i][j] > res) res = dp[i][j];
            }
        }

        return res;
    }
}
```



#### [1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/)

``` java
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        // dp[i][j]: 以nums1[i - 1], nums2[j - 1] 结尾的最长公共数组的长度
        int res = 0;
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];
        dp[0][0] = 0;
        for (int i = 1; i < nums1.length + 1; i++) { 
            for (int j = 1; j < nums2.length + 1; j++) {
                if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = dp[i - 1][j] > dp[i][j - 1] ? dp[i - 1][j] : dp[i][j - 1];
                if (dp[i][j] > res) res = dp[i][j];
            }
        }

        return res;
    }
}
```



#### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

``` java
class Solution {
    public int maxSubArray(int[] nums) {
        // dp[i]：表示下标i为结尾的连续子数组的最大和
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int res = nums[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);
            if (dp[i] > res) res = dp[i];
        }

        return res;
    }
}
```



### 编辑距离

#### [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

```` java
class Solution {
    public boolean isSubsequence(String s, String t) {
        // dp[i][j]: 以s[i - 1], t[j - 1]结尾的最长公共子序列的长度
        // dp[i][j] = dp[i - 1][j - 1] + 1 if s[i - 1] == t[j - 1] else dp[i][j] = dp[i][j - 1]
        char[] ss = s.toCharArray(), tt = t.toCharArray();
        if (ss.length == 0) return true;
        if (tt.length == 0) return false;

        int[][] dp = new int[ss.length + 1][tt.length + 1];
        int res = 0;
        dp[0][0] = 0;
        for (int i = 1; i < ss.length + 1; i++) {
            for (int j = 1; j < tt.length + 1; j++) {
                if (ss[i - 1] == tt[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = dp[i][j - 1]; // ss不能缺少，tt可以缺少
                if (dp[i][j] > res) res = dp[i][j];
            }
        }

        return res == ss.length;
    }
}
````



#### [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

``` java
class Solution {
    public int numDistinct(String t, String s) {
        // dp[i][j]: 以s[i - 1], t[j - 1]结尾s序列在t序列中出现的次数
        // dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1] if s[i - 1] == t[j - 1] else dp[i][j] = dp[i][j - 1]
        char[] ss = s.toCharArray(), tt = t.toCharArray();
        int[][] dp = new int[ss.length + 1][tt.length + 1];
        for (int i = 1; i <= ss.length; i++) dp[i][0] = 0;
        for (int i = 0; i <= tt.length; i++) dp[0][i] = 1; 

        for (int i = 1; i <= ss.length; i++) {
            for (int j = 1; j <= tt.length; j++) {
                if (ss[i - 1] != tt[j - 1]) dp[i][j] = dp[i][j - 1];
                else dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1];
            }
        }

        return dp[ss.length][tt.length];
    }
}
```



#### [583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)

``` java
class Solution {
    public int minDistance(String word1, String word2) {
        // dp[i][j]: 表示word1[i - 1], word2[j - 1]结尾的最长公共子序列长度
        char[] w1 = word1.toCharArray(), w2 = word2.toCharArray();
        int[][] dp = new int[w1.length + 1][w2.length + 1];
        dp[0][0] = 0;
        for (int i = 1; i <= w1.length; i++) {
            for (int j = 1; j <= w2.length; j++) {
                if(w1[i - 1] == w2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }

        return w1.length + w2.length - 2 * dp[w1.length][w2.length];
    }
}
```



#### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

``` java
class Solution {
    public int minDistance(String word1, String word2) {
        // dp[i][j]: 表示w1[i - 1], w2[j - 1]结尾的最小操作次数
        char[] w1 = word1.toCharArray(), w2 = word2.toCharArray();
        int[][] dp = new int[w1.length + 1][w2.length + 1];
        for (int i = 0; i <= w1.length; i++) dp[i][0] = i;
        for (int j = 0; j <= w2.length; j++) dp[0][j] = j;

        for (int i = 1; i <= w1.length; i++) {
            for (int j = 1; j <= w2.length; j++) {
                if (w1[i - 1] == w2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; // 相等不用操作
                else {// 不等，可以，w1删除，w2删除,w1或者w2修改
                    dp[i][j] = Math.min(dp[i - 1][j] + 1, Math.min(dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1));
                }
            }
        }

        return dp[w1.length][w2.length];
    }
}
```



### 回文串

#### [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

``` java
class Solution {
    public int countSubstrings(String s) {
        // dp[i][j]: s[i], s[j] 子串是否为回文子串
        char[] ss = s.toCharArray();
        int[][] dp = new int[ss.length][ss.length];

        int res = 0;
        for (int i = 1; i <= ss.length; i++) { // 枚举区间宽度
            for (int j = 0; j + i - 1 < ss.length; j++) { // 枚举左侧区间
                if (i == 1) {
                    dp[j][j] = 1;
                }else if (ss[j] == ss[i + j - 1]) {
                    if (i == 2) {
                        dp[j][i + j - 1] = 1;
                    } else {
                        dp[j][i + j - 1] = dp[j + 1][i + j - 2];
                    }
                }
                res += dp[j][i + j - 1];
            }
        }

        return res;
    }
}
```



#### [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

``` java
class Solution {
    public int longestPalindromeSubseq(String s) {
        // dp[i][j]: s[i], s[j]中回文子序列的最长长度
        char[] ss = s.toCharArray();
        int[][] dp = new int[ss.length][ss.length];
        for (int i = 1; i <= ss.length; i++) { // 枚举长度
            for (int j = 0; j + i - 1 < ss.length; j++) { // 枚举左边界
                if (i == 1) {
                    dp[j][j + i - 1] = 1;
                } else if (ss[j] == ss[i + j - 1]){
                    if (i == 2) dp[j][i + j - 1] = 2;
                    else dp[j][i + j - 1] = dp[j + 1][i + j - 2] + 2;
                } else {
                    dp[j][i + j - 1] = Math.max(dp[j + 1][i + j - 1], dp[j][i + j - 2]);
                }
            }
        }

        return dp[0][ss.length - 1];
    }
}
```



## 11. 单调栈(5)

#### [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

找右边第一个比自己大的元素

``` java
class Solution {
    public int[] dailyTemperatures(int[] temp) {
        // 单调栈
        // 要求一个元素的右侧最近的比它大的数，则栈应该从栈顶到栈底单调递增
        Deque<Integer> st = new LinkedList<>();
        int[] res = new int[temp.length];

        for (int i = 0; i < temp.length; i++) {
            if (st.isEmpty()) st.push(i);
            else {
                while (!st.isEmpty() && temp[st.peek()] < temp[i]) {
                    int t = st.pop();
                    res[t] = i - t;
                }
                st.push(i);
            }
        }

        return res;
    }
}
```



#### [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

``` java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        // 单调栈
        // 找元素右侧第一个比自己大的元素，用单调递增栈，从栈顶到栈底
        Map<Integer, Integer> map = new HashMap<>();
        int[] res = new int[nums1.length];
        Deque<Integer> st = new LinkedList<>();

        for (int i = 0; i < nums2.length; i++) {
            while (!st.isEmpty() && nums2[st.peek()] < nums2[i]) {
                int t = st.pop();
                map.put(nums2[t], nums2[i]);
            }
            st.push(i);
        }

        for (int i = 0; i < nums1.length; i++) {
            if (!map.containsKey(nums1[i])) res[i] = -1;
            else res[i] = map.get(nums1[i]);
        }

        return res;
    }
}
```



#### [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

``` java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int[] res = new int[nums.length];
        Arrays.fill(res, -1);
        Deque<Integer> st = new LinkedList<>();

        for (int i = 0; i < nums.length * 2; i++) {
            while (!st.isEmpty() && nums[st.peek()] < nums[i % nums.length]) { // 循环
                int t = st.pop();
                res[t] = nums[i % nums.length]; 
            }
            if (i > nums.length - 1) continue; // 此时i已经没有意义，不用放入栈中
            st.push(i);
        }

        return res;
    }
}
```



#### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

```` java
class Solution {
    public int trap(int[] height) {
        Deque<Integer> st = new LinkedList<>();
        int res = 0;
        for (int i = 0 ; i < height.length; i++) {
            while (!st.isEmpty() && height[st.peek()] < height[i]) { // 相同高度的柱子，在计算的时候会导致乘积为0
                int mid = st.pop();
                if (!st.isEmpty()) {
                    int h = Math.min(height[st.peek()], height[i]) - height[mid]; // 找凹槽，横向计算面积
                    int w = i - st.peek() - 1;
                    res += h * w;
                }
            }
            st.push(i);
        }
        return res;
    }
}
````



#### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

``` java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int[] h = new int[heights.length + 2];
        h[0] = 0;
        h[heights.length + 1] = 0;
        for (int i = 1; i < heights.length + 1; i++) {
            h[i] = heights[i - 1]; // 0 - length - 1
        }

        int res = 0;

        Deque<Integer> st = new LinkedList<>();
        for (int i = 0; i < h.length; i++) {
            while (!st.isEmpty() && h[i] < h[st.peek()]) {
                int mid = st.pop();
                res = Math.max(res, (i - st.peek() - 1) * h[mid]);
            }
            st.push(i);
        }

        return res;
    }
}
```
